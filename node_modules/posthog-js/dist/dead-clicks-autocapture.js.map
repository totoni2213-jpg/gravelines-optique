{"version":3,"file":"dead-clicks-autocapture.js","sources":["../src/utils/globals.ts","../../core/dist/utils/string-utils.mjs","../../core/dist/utils/type-utils.mjs","../src/utils/logger.ts","../src/utils/index.ts","../src/utils/element-utils.ts","../src/autocapture-utils.ts","../src/autocapture.ts","../src/utils/request-utils.ts","../src/utils/type-utils.ts","../src/utils/prototype-utils.ts","../src/entrypoints/dead-clicks-autocapture.ts","../src/constants.ts"],"sourcesContent":["import type { PostHog } from '../posthog-core'\nimport { SessionIdManager } from '../sessionid'\nimport {\n    DeadClicksAutoCaptureConfig,\n    ExternalIntegrationKind,\n    Properties,\n    RemoteConfig,\n    SiteAppLoader,\n    SessionStartReason,\n} from '../types'\nimport type {\n    ConversationsRemoteConfig,\n    GetMessagesResponse,\n    GetTicketsOptions,\n    GetTicketsResponse,\n    MarkAsReadResponse,\n    RestoreFromTokenResponse,\n    RequestRestoreLinkResponse,\n    SendMessageResponse,\n    UserProvidedTraits,\n} from '../posthog-conversations-types'\n// only importing types here, so won't affect the bundle\n// eslint-disable-next-line posthog-js/no-external-replay-imports\nimport type { SessionRecordingStatus, TriggerType } from '../extensions/replay/external/triggerMatching'\nimport { eventWithTime } from '../extensions/replay/types/rrweb-types'\nimport { ErrorTracking } from '@posthog/core'\n\n/*\n * Global helpers to protect access to browser globals in a way that is safer for different targets\n * like DOM, SSR, Web workers etc.\n *\n * NOTE: Typically we want the \"window\" but globalThis works for both the typical browser context as\n * well as other contexts such as the web worker context. Window is still exported for any bits that explicitly require it.\n * If in doubt - export the global you need from this file and use that as an optional value. This way the code path is forced\n * to handle the case where the global is not available.\n */\n\n// eslint-disable-next-line no-restricted-globals\nconst win: (Window & typeof globalThis) | undefined = typeof window !== 'undefined' ? window : undefined\n\nexport type AssignableWindow = Window &\n    typeof globalThis & {\n        /*\n         * Main PostHog instance\n         */\n        posthog: any\n\n        /*\n         * This is our contract between (potentially) lazily loaded extensions and the SDK\n         */\n        __PosthogExtensions__?: PostHogExtensions\n\n        /**\n         * When loading remote config, we assign it to this global configuration\n         * for ease of sharing it with the rest of the SDK\n         */\n        _POSTHOG_REMOTE_CONFIG?: Record<\n            string,\n            {\n                config: RemoteConfig\n                siteApps: SiteAppLoader[]\n            }\n        >\n\n        /**\n         * If this is set on the window, our logger will log to the console\n         * for ease of debugging. Used for testing purposes only.\n         *\n         * @see {Config.DEBUG} from config.ts\n         */\n        POSTHOG_DEBUG: any\n\n        // Exposed by the browser\n        doNotTrack: any\n\n        // See entrypoints/customizations.full.ts\n        posthogCustomizations: any\n\n        /**\n         * This is a legacy way to expose these functions, but we still need to support it for backwards compatibility\n         * Can be removed once we drop support for 1.161.1\n         *\n         * See entrypoints/exception-autocapture.ts\n         *\n         * @deprecated use `__PosthogExtensions__.errorWrappingFunctions` instead\n         */\n        posthogErrorWrappingFunctions: any\n\n        /**\n         * This is a legacy way to expose these functions, but we still need to support it for backwards compatibility\n         * Can be removed once we drop support for 1.161.1\n         *\n         * See entrypoints/posthog-recorder.ts\n         *\n         * @deprecated use `__PosthogExtensions__.rrweb` instead\n         */\n        rrweb: any\n\n        /**\n         * This is a legacy way to expose these functions, but we still need to support it for backwards compatibility\n         * Can be removed once we drop support for 1.161.1\n         *\n         * See entrypoints/posthog-recorder.ts\n         *\n         * @deprecated use `__PosthogExtensions__.rrwebConsoleRecord` instead\n         */\n        rrwebConsoleRecord: any\n\n        /**\n         * This is a legacy way to expose these functions, but we still need to support it for backwards compatibility\n         * Can be removed once we drop support for 1.161.1\n         *\n         * See entrypoints/posthog-recorder.ts\n         *\n         * @deprecated use `__PosthogExtensions__.getRecordNetworkPlugin` instead\n         */\n        getRecordNetworkPlugin: any\n\n        /**\n         * This is a legacy way to expose these functions, but we still need to support it for backwards compatibility\n         * Can be removed once we drop support for 1.161.1\n         *\n         * See entrypoints/web-vitals.ts\n         *\n         * @deprecated use `__PosthogExtensions__.postHogWebVitalsCallbacks` instead\n         */\n        postHogWebVitalsCallbacks: any\n\n        /**\n         * This is a legacy way to expose these functions, but we still need to support it for backwards compatibility\n         * Can be removed once we drop support for 1.161.1\n         *\n         * See entrypoints/tracing-headers.ts\n         *\n         * @deprecated use `__PosthogExtensions__.postHogTracingHeadersPatchFns` instead\n         */\n        postHogTracingHeadersPatchFns: any\n\n        /**\n         * This is a legacy way to expose these functions, but we still need to support it for backwards compatibility\n         * Can be removed once we drop support for 1.161.1\n         *\n         * See entrypoints/surveys.ts\n         *\n         * @deprecated use `__PosthogExtensions__.generateSurveys` instead\n         */\n        extendPostHogWithSurveys: any\n\n        /*\n         * These are used to handle our toolbar state.\n         * @see {Toolbar} from extensions/toolbar.ts\n         */\n        ph_load_toolbar: any\n        ph_load_editor: any\n        ph_toolbar_state: any\n    } & Record<`__$$ph_site_app_${string}`, any>\n\n/**\n * This is our contract between (potentially) lazily loaded extensions and the SDK\n * changes to this interface can be breaking changes for users of the SDK\n */\n\nexport type ExternalExtensionKind = 'intercom-integration' | 'crisp-chat-integration'\n\nexport type PostHogExtensionKind =\n    | 'toolbar'\n    | 'exception-autocapture'\n    | 'web-vitals'\n    | 'web-vitals-with-attribution'\n    | 'recorder'\n    | 'lazy-recorder'\n    | 'tracing-headers'\n    | 'surveys'\n    | 'logs'\n    | 'conversations'\n    | 'product-tours'\n    | 'dead-clicks-autocapture'\n    | 'remote-config'\n    | ExternalExtensionKind\n\nexport interface LazyLoadedSessionRecordingInterface {\n    start: (startReason?: SessionStartReason) => void\n    stop: () => void\n    sessionId: string\n    status: SessionRecordingStatus\n    onRRwebEmit: (rawEvent: eventWithTime) => void\n    log: (message: string, level: 'log' | 'warn' | 'error') => void\n    sdkDebugProperties: Properties\n    overrideLinkedFlag: () => void\n    overrideSampling: () => void\n    overrideTrigger: (triggerType: TriggerType) => void\n    isStarted: boolean\n    tryAddCustomEvent(tag: string, payload: any): boolean\n}\n\nexport interface LazyLoadedDeadClicksAutocaptureInterface {\n    start: (observerTarget: Node) => void\n    stop: () => void\n}\n\nexport interface LazyLoadedConversationsInterface {\n    // Widget control\n    show: () => void\n    hide: () => void\n    isVisible: () => boolean\n\n    // Lifecycle\n    reset: () => void\n\n    // API methods\n    sendMessage: (message: string, userTraits?: UserProvidedTraits, newTicket?: boolean) => Promise<SendMessageResponse>\n    getMessages: (ticketId?: string, after?: string) => Promise<GetMessagesResponse>\n    markAsRead: (ticketId?: string) => Promise<MarkAsReadResponse>\n    getTickets: (options?: GetTicketsOptions) => Promise<GetTicketsResponse>\n    requestRestoreLink: (email: string) => Promise<RequestRestoreLinkResponse>\n    restoreFromToken: (restoreToken: string) => Promise<RestoreFromTokenResponse>\n    restoreFromUrlToken: () => Promise<RestoreFromTokenResponse | null>\n    getCurrentTicketId: () => string | null\n    getWidgetSessionId: () => string\n}\n\ninterface PostHogExtensions {\n    loadExternalDependency?: (\n        posthog: PostHog,\n        kind: PostHogExtensionKind,\n        callback: (error?: string | Event, event?: Event) => void\n    ) => void\n\n    loadSiteApp?: (posthog: PostHog, appUrl: string, callback: (error?: string | Event, event?: Event) => void) => void\n\n    errorWrappingFunctions?: {\n        wrapOnError: (captureFn: (props: ErrorTracking.ErrorProperties) => void) => () => void\n        wrapUnhandledRejection: (captureFn: (props: ErrorTracking.ErrorProperties) => void) => () => void\n        wrapConsoleError: (captureFn: (props: ErrorTracking.ErrorProperties) => void) => () => void\n    }\n    rrweb?: { record: any; version: string; wasMaxDepthReached?: () => boolean; resetMaxDepthState?: () => void }\n    rrwebPlugins?: { getRecordConsolePlugin: any; getRecordNetworkPlugin?: any }\n    generateSurveys?: (posthog: PostHog, isSurveysEnabled: boolean) => any | undefined\n    generateProductTours?: (posthog: PostHog, isEnabled: boolean) => any | undefined\n    logs?: {\n        initializeLogs?: (posthog: PostHog) => any | undefined\n    }\n    postHogWebVitalsCallbacks?: {\n        onLCP: (metric: any) => void\n        onCLS: (metric: any) => void\n        onFCP: (metric: any) => void\n        onINP: (metric: any) => void\n    }\n    /**\n     * @deprecated\n     *\n     * this was introduced briefly, it is now always a no-op and only kept for backwards compatibility\n     */\n    loadWebVitalsCallbacks?: (useAttribution?: boolean) => PostHogExtensions['postHogWebVitalsCallbacks']\n    tracingHeadersPatchFns?: {\n        _patchFetch: (hostnames: string[], distinctId: string, sessionManager?: SessionIdManager) => () => void\n        _patchXHR: (hostnames: string[], distinctId: string, sessionManager?: SessionIdManager) => () => void\n    }\n    initDeadClicksAutocapture?: (\n        ph: PostHog,\n        config: DeadClicksAutoCaptureConfig\n    ) => LazyLoadedDeadClicksAutocaptureInterface\n    integrations?: {\n        [K in ExternalIntegrationKind]?: { start: (posthog: PostHog) => void; stop: () => void }\n    }\n    initSessionRecording?: (ph: PostHog) => LazyLoadedSessionRecordingInterface\n    initConversations?: (config: ConversationsRemoteConfig, posthog: PostHog) => LazyLoadedConversationsInterface\n}\n\nconst global: typeof globalThis | undefined = typeof globalThis !== 'undefined' ? globalThis : win\n\n// React Native polyfills for posthog-js compatibility\nif (typeof self === 'undefined') {\n    ;(global as any).self = global\n}\nif (typeof File === 'undefined') {\n    ;(global as any).File = function () {}\n}\n\nexport const ArrayProto = Array.prototype\nexport const nativeForEach = ArrayProto.forEach\nexport const nativeIndexOf = ArrayProto.indexOf\n\nexport const navigator = global?.navigator\nexport const document = global?.document\nexport const location = global?.location\nexport const fetch = global?.fetch\nexport const XMLHttpRequest =\n    global?.XMLHttpRequest && 'withCredentials' in new global.XMLHttpRequest() ? global.XMLHttpRequest : undefined\nexport const AbortController = global?.AbortController\nexport const userAgent = navigator?.userAgent\nexport const assignableWindow: AssignableWindow = win ?? ({} as any)\n\nexport { win as window }\n","function includes(str, needle) {\n    return -1 !== str.indexOf(needle);\n}\nconst trim = function(str) {\n    return str.trim();\n};\nconst stripLeadingDollar = function(s) {\n    return s.replace(/^\\$/, '');\n};\nfunction isDistinctIdStringLike(value) {\n    return [\n        'distinct_id',\n        'distinctid'\n    ].includes(value.toLowerCase());\n}\nfunction deepSortKeys(value) {\n    if (null === value || 'object' != typeof value) return value;\n    if (Array.isArray(value)) return value.map(deepSortKeys);\n    return Object.keys(value).sort().reduce((acc, key)=>{\n        acc[key] = deepSortKeys(value[key]);\n        return acc;\n    }, {});\n}\nfunction getPersonPropertiesHash(distinct_id, userPropertiesToSet, userPropertiesToSetOnce) {\n    return JSON.stringify({\n        distinct_id,\n        userPropertiesToSet: userPropertiesToSet ? deepSortKeys(userPropertiesToSet) : void 0,\n        userPropertiesToSetOnce: userPropertiesToSetOnce ? deepSortKeys(userPropertiesToSetOnce) : void 0\n    });\n}\nexport { getPersonPropertiesHash, includes, isDistinctIdStringLike, stripLeadingDollar, trim };\n","import { knownUnsafeEditableEvent } from \"../types.mjs\";\nimport { includes } from \"./string-utils.mjs\";\nconst nativeIsArray = Array.isArray;\nconst ObjProto = Object.prototype;\nconst type_utils_hasOwnProperty = ObjProto.hasOwnProperty;\nconst type_utils_toString = ObjProto.toString;\nconst isArray = nativeIsArray || function(obj) {\n    return '[object Array]' === type_utils_toString.call(obj);\n};\nconst isFunction = (x)=>'function' == typeof x;\nconst isNativeFunction = (x)=>isFunction(x) && -1 !== x.toString().indexOf('[native code]');\nconst isObject = (x)=>x === Object(x) && !isArray(x);\nconst isEmptyObject = (x)=>{\n    if (isObject(x)) {\n        for(const key in x)if (type_utils_hasOwnProperty.call(x, key)) return false;\n        return true;\n    }\n    return false;\n};\nconst isUndefined = (x)=>void 0 === x;\nconst isString = (x)=>'[object String]' == type_utils_toString.call(x);\nconst isEmptyString = (x)=>isString(x) && 0 === x.trim().length;\nconst isNull = (x)=>null === x;\nconst isNullish = (x)=>isUndefined(x) || isNull(x);\nconst isNumber = (x)=>'[object Number]' == type_utils_toString.call(x) && x === x;\nconst isPositiveNumber = (value)=>isNumber(value) && value > 0;\nconst isBoolean = (x)=>'[object Boolean]' === type_utils_toString.call(x);\nconst isFormData = (x)=>x instanceof FormData;\nconst isFile = (x)=>x instanceof File;\nconst isPlainError = (x)=>x instanceof Error;\nconst isKnownUnsafeEditableEvent = (x)=>includes(knownUnsafeEditableEvent, x);\nfunction isPrimitive(value) {\n    return null === value || 'object' != typeof value;\n}\nfunction isBuiltin(candidate, className) {\n    return Object.prototype.toString.call(candidate) === `[object ${className}]`;\n}\nfunction isError(candidate) {\n    switch(Object.prototype.toString.call(candidate)){\n        case '[object Error]':\n        case '[object Exception]':\n        case '[object DOMException]':\n        case '[object DOMError]':\n        case '[object WebAssembly.Exception]':\n            return true;\n        default:\n            return isInstanceOf(candidate, Error);\n    }\n}\nfunction isErrorEvent(event) {\n    return isBuiltin(event, 'ErrorEvent');\n}\nfunction isEvent(candidate) {\n    return !isUndefined(Event) && isInstanceOf(candidate, Event);\n}\nfunction isPlainObject(candidate) {\n    return isBuiltin(candidate, 'Object');\n}\nfunction isInstanceOf(candidate, base) {\n    try {\n        return candidate instanceof base;\n    } catch  {\n        return false;\n    }\n}\nconst yesLikeValues = [\n    true,\n    'true',\n    1,\n    '1',\n    'yes'\n];\nconst isYesLike = (val)=>includes(yesLikeValues, val);\nconst noLikeValues = [\n    false,\n    'false',\n    0,\n    '0',\n    'no'\n];\nconst isNoLike = (val)=>includes(noLikeValues, val);\nexport { type_utils_hasOwnProperty as hasOwnProperty, isArray, isBoolean, isBuiltin, isEmptyObject, isEmptyString, isError, isErrorEvent, isEvent, isFile, isFormData, isFunction, isKnownUnsafeEditableEvent, isNativeFunction, isNoLike, isNull, isNullish, isNumber, isObject, isPlainError, isPlainObject, isPositiveNumber, isPrimitive, isString, isUndefined, isYesLike, noLikeValues, yesLikeValues };\n","import Config from '../config'\nimport { isUndefined } from '@posthog/core'\nimport { assignableWindow, window } from './globals'\nimport type { Logger } from '@posthog/core'\n\ntype CreateLoggerOptions = {\n    debugEnabled?: boolean\n}\n\ntype PosthogJsLogger = Omit<Logger, 'createLogger'> & {\n    _log: (level: 'log' | 'warn' | 'error', ...args: any[]) => void\n    uninitializedWarning: (methodName: string) => void\n    createLogger: (prefix: string, options?: CreateLoggerOptions) => PosthogJsLogger\n}\n\nconst _createLogger = (prefix: string, { debugEnabled }: CreateLoggerOptions = {}): PosthogJsLogger => {\n    const logger: PosthogJsLogger = {\n        _log: (level: 'log' | 'warn' | 'error', ...args: any[]) => {\n            if (\n                window &&\n                (Config.DEBUG || assignableWindow.POSTHOG_DEBUG || debugEnabled) &&\n                !isUndefined(window.console) &&\n                window.console\n            ) {\n                const consoleLog =\n                    '__rrweb_original__' in window.console[level]\n                        ? (window.console[level] as any)['__rrweb_original__']\n                        : window.console[level]\n\n                // eslint-disable-next-line no-console\n                consoleLog(prefix, ...args)\n            }\n        },\n\n        info: (...args: any[]) => {\n            logger._log('log', ...args)\n        },\n\n        warn: (...args: any[]) => {\n            logger._log('warn', ...args)\n        },\n\n        error: (...args: any[]) => {\n            logger._log('error', ...args)\n        },\n\n        critical: (...args: any[]) => {\n            // Critical errors are always logged to the console\n            // eslint-disable-next-line no-console\n            console.error(prefix, ...args)\n        },\n\n        uninitializedWarning: (methodName: string) => {\n            logger.error(`You must initialize PostHog before calling ${methodName}`)\n        },\n\n        createLogger: (additionalPrefix: string, options?: CreateLoggerOptions) =>\n            _createLogger(`${prefix} ${additionalPrefix}`, options),\n    }\n    return logger\n}\n\nexport const logger = _createLogger('[PostHog.js]')\n\nexport const createLogger = logger.createLogger\n","import { Breaker, Properties } from '../types'\nimport { nativeForEach, nativeIndexOf } from './globals'\nimport { logger } from './logger'\nimport { isFormData, isNull, isNullish, isNumber, isString, hasOwnProperty, isArray } from '@posthog/core'\n\nconst breaker: Breaker = {}\n\nexport function eachArray<E = any>(\n    obj: E[] | null | undefined,\n    iterator: (value: E, key: number) => void | Breaker,\n    thisArg?: any\n): void {\n    if (isArray(obj)) {\n        if (nativeForEach && obj.forEach === nativeForEach) {\n            obj.forEach(iterator, thisArg)\n        } else if ('length' in obj && obj.length === +obj.length) {\n            for (let i = 0, l = obj.length; i < l; i++) {\n                if (i in obj && iterator.call(thisArg, obj[i], i) === breaker) {\n                    return\n                }\n            }\n        }\n    }\n}\n\n/**\n * @param {*=} obj\n * @param {function(...*)=} iterator\n * @param {Object=} thisArg\n */\nexport function each(obj: any, iterator: (value: any, key: any) => void | Breaker, thisArg?: any): void {\n    if (isNullish(obj)) {\n        return\n    }\n    if (isArray(obj)) {\n        return eachArray(obj, iterator, thisArg)\n    }\n    if (isFormData(obj)) {\n        for (const pair of obj.entries()) {\n            if (iterator.call(thisArg, pair[1], pair[0]) === breaker) {\n                return\n            }\n        }\n        return\n    }\n    for (const key in obj) {\n        if (hasOwnProperty.call(obj, key)) {\n            if (iterator.call(thisArg, obj[key], key) === breaker) {\n                return\n            }\n        }\n    }\n}\n\nexport const extend = function (obj: Record<string, any>, ...args: Record<string, any>[]): Record<string, any> {\n    eachArray(args, function (source) {\n        for (const prop in source) {\n            if (source[prop] !== void 0) {\n                obj[prop] = source[prop]\n            }\n        }\n    })\n    return obj\n}\n\nexport const extendArray = function <T>(obj: T[], ...args: T[][]): T[] {\n    eachArray(args, function (source) {\n        eachArray(source, function (item) {\n            obj.push(item)\n        })\n    })\n    return obj\n}\n\nexport const include = function (\n    obj: null | string | Array<any> | Record<string, any>,\n    target: any\n): boolean | Breaker {\n    let found = false\n    if (isNull(obj)) {\n        return found\n    }\n    if (nativeIndexOf && obj.indexOf === nativeIndexOf) {\n        return obj.indexOf(target) != -1\n    }\n    each(obj, function (value) {\n        if (found || (found = value === target)) {\n            return breaker\n        }\n        return\n    })\n    return found\n}\n\n/**\n * Object.entries() polyfill\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries\n */\nexport function entries<T = any>(obj: Record<string, T>): [string, T][] {\n    const ownProps = Object.keys(obj)\n    let i = ownProps.length\n    const resArray = new Array(i) // preallocate the Array\n\n    while (i--) {\n        resArray[i] = [ownProps[i], obj[ownProps[i]]]\n    }\n    return resArray\n}\n\nexport const trySafe = function <T>(fn: () => T): T | undefined {\n    try {\n        return fn()\n    } catch {\n        return undefined\n    }\n}\n\nexport const safewrap = function <F extends (...args: any[]) => any = (...args: any[]) => any>(f: F): F {\n    return function (...args) {\n        try {\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore\n            return f.apply(this, args)\n        } catch (e) {\n            logger.critical(\n                'Implementation error. Please turn on debug mode and open a ticket on https://app.posthog.com/home#panel=support%3Asupport%3A.'\n            )\n            logger.critical(e)\n        }\n    } as F\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unsafe-function-type\nexport const safewrapClass = function (klass: Function, functions: string[]): void {\n    for (let i = 0; i < functions.length; i++) {\n        klass.prototype[functions[i]] = safewrap(klass.prototype[functions[i]])\n    }\n}\n\nexport const stripEmptyProperties = function (p: Properties): Properties {\n    const ret: Properties = {}\n    each(p, function (v, k) {\n        if ((isString(v) && v.length > 0) || isNumber(v)) {\n            ret[k] = v\n        }\n    })\n    return ret\n}\n\n/**\n * Deep copies an object.\n * It handles cycles by replacing all references to them with `undefined`\n * Also supports customizing native values\n *\n * @param value\n * @param customizer\n * @returns {{}|undefined|*}\n */\nfunction deepCircularCopy<T extends Record<string, any> = Record<string, any>>(\n    value: T,\n    customizer?: <K extends keyof T = keyof T>(value: T[K], key?: K) => T[K]\n): T | undefined {\n    const COPY_IN_PROGRESS_SET = new Set()\n\n    function internalDeepCircularCopy(value: T, key?: string): T | undefined {\n        if (value !== Object(value)) return customizer ? customizer(value as any, key) : value // primitive value\n\n        if (COPY_IN_PROGRESS_SET.has(value)) return undefined\n        COPY_IN_PROGRESS_SET.add(value)\n        let result: T\n\n        if (isArray(value)) {\n            result = [] as any as T\n            eachArray(value, (it) => {\n                result.push(internalDeepCircularCopy(it))\n            })\n        } else {\n            result = {} as T\n            each(value, (val, key) => {\n                if (!COPY_IN_PROGRESS_SET.has(val)) {\n                    ;(result as any)[key] = internalDeepCircularCopy(val, key)\n                }\n            })\n        }\n        return result\n    }\n    return internalDeepCircularCopy(value)\n}\n\nexport function _copyAndTruncateStrings<T extends Record<string, any> = Record<string, any>>(\n    object: T,\n    maxStringLength: number | null\n): T {\n    return deepCircularCopy(object, (value: any) => {\n        if (isString(value) && !isNull(maxStringLength)) {\n            return (value as string).slice(0, maxStringLength)\n        }\n        return value\n    }) as T\n}\n\n// NOTE: Update PostHogConfig docs if you change this list\n// We will not try to catch all bullets here, but we should make an effort to catch the most common ones\n// You should be highly against adding more to this list, because ultimately customers can configure\n// their `cross_subdomain_cookie` setting to anything they want.\nconst EXCLUDED_FROM_CROSS_SUBDOMAIN_COOKIE = ['herokuapp.com', 'vercel.app', 'netlify.app']\nexport function isCrossDomainCookie(documentLocation: Location | undefined) {\n    const hostname = documentLocation?.hostname\n\n    if (!isString(hostname)) {\n        return false\n    }\n    // split and slice isn't a great way to match arbitrary domains,\n    // but it's good enough for ensuring we only match herokuapp.com when it is the TLD\n    // for the hostname\n    const lastTwoParts = hostname.split('.').slice(-2).join('.')\n\n    for (const excluded of EXCLUDED_FROM_CROSS_SUBDOMAIN_COOKIE) {\n        if (lastTwoParts === excluded) {\n            return false\n        }\n    }\n\n    return true\n}\n\nexport function find<T>(value: T[], predicate: (value: T) => boolean): T | undefined {\n    for (let i = 0; i < value.length; i++) {\n        if (predicate(value[i])) {\n            return value[i]\n        }\n    }\n    return undefined\n}\n\n// Use this instead of element.addEventListener to avoid eslint errors\n// this properly implements the default options for passive event listeners\nexport function addEventListener(\n    element: Window | Document | Element | undefined,\n    event: string,\n    callback: EventListener,\n    options?: AddEventListenerOptions\n): void {\n    const { capture = false, passive = true } = options ?? {}\n\n    // This is the only place where we are allowed to call this function\n    // because the whole idea is that we should be calling this instead of the built-in one\n    // eslint-disable-next-line posthog-js/no-add-event-listener\n    element?.addEventListener(event, callback, { capture, passive })\n}\n\n/**\n * Helper to migrate deprecated config fields to new field names with appropriate warnings\n * @param config - The config object to check\n * @param newField - The new field name to use\n * @param oldField - The deprecated field name to check for\n * @param defaultValue - The default value if neither field is set\n * @param loggerInstance - Optional logger instance for deprecation warnings\n * @returns The value to use (new field takes precedence over old field)\n */\nexport function migrateConfigField<T>(\n    config: Record<string, any>,\n    newField: string,\n    oldField: string,\n    defaultValue: T,\n    loggerInstance?: { warn: (message: string) => void }\n): T {\n    const hasNewField = newField in config && !isNullish(config[newField])\n    const hasOldField = oldField in config && !isNullish(config[oldField])\n\n    if (hasNewField) {\n        return config[newField]\n    }\n\n    if (hasOldField) {\n        if (loggerInstance) {\n            loggerInstance.warn(\n                `Config field '${oldField}' is deprecated. Please use '${newField}' instead. ` +\n                    `The old field will be removed in a future major version.`\n            )\n        }\n        return config[oldField]\n    }\n\n    return defaultValue\n}\n","import { TOOLBAR_CONTAINER_CLASS, TOOLBAR_ID } from '../constants'\n\nexport function isElementInToolbar(el: EventTarget | null): boolean {\n    if (el instanceof Element) {\n        // closest isn't available in IE11, but we'll polyfill when bundling\n        return el.id === TOOLBAR_ID || !!el.closest?.('.' + TOOLBAR_CONTAINER_CLASS)\n    }\n    return false\n}\n\n/*\n * Check whether an element has nodeType Node.ELEMENT_NODE\n * @param {Element} el - element to check\n * @returns {boolean} whether el is of the correct nodeType\n */\nexport function isElementNode(el: Node | Element | undefined | null): el is Element {\n    return !!el && el.nodeType === 1 // Node.ELEMENT_NODE - use integer constant for browser portability\n}\n\n/*\n * Check whether an element is of a given tag type.\n * Due to potential reference discrepancies (such as the webcomponents.js polyfill),\n * we want to match tagNames instead of specific references because something like\n * element === document.body won't always work because element might not be a native\n * element.\n * @param {Element} el - element to check\n * @param {string} tag - tag name (e.g., \"div\")\n * @returns {boolean} whether el is of the given tag type\n */\nexport function isTag(el: Element | undefined | null, tag: string): el is HTMLElement {\n    return !!el && !!el.tagName && el.tagName.toLowerCase() === tag.toLowerCase()\n}\n\n/*\n * Check whether an element has nodeType Node.TEXT_NODE\n * @param {Element} el - element to check\n * @returns {boolean} whether el is of the correct nodeType\n */\nexport function isTextNode(el: Element | undefined | null): el is HTMLElement {\n    return !!el && el.nodeType === 3 // Node.TEXT_NODE - use integer constant for browser portability\n}\n\n/*\n * Check whether an element has nodeType Node.DOCUMENT_FRAGMENT_NODE\n * @param {Element} el - element to check\n * @returns {boolean} whether el is of the correct nodeType\n */\nexport function isDocumentFragment(el: Element | ParentNode | undefined | null): el is DocumentFragment {\n    return !!el && el.nodeType === 11 // Node.DOCUMENT_FRAGMENT_NODE - use integer constant for browser portability\n}\n","import { AutocaptureConfig, PostHogConfig, Properties } from './types'\nimport { each, entries } from './utils'\n\nimport { isNullish, isString, isUndefined, isArray, isBoolean } from '@posthog/core'\nimport { logger } from './utils/logger'\nimport { window } from './utils/globals'\nimport { isDocumentFragment, isElementNode, isTag, isTextNode } from './utils/element-utils'\nimport { includes, trim } from '@posthog/core'\n\nexport function splitClassString(s: string): string[] {\n    return s ? trim(s).split(/\\s+/) : []\n}\n\nfunction checkForURLMatches(urlsList: (string | RegExp)[]): boolean {\n    const url = window?.location.href\n    return !!(url && urlsList && urlsList.some((regex) => url.match(regex)))\n}\n\n/*\n * Get the className of an element, accounting for edge cases where element.className is an object\n *\n * Because this is a string it can contain unexpected characters\n * So, this method safely splits the className and returns that array.\n */\nexport function getClassNames(el: Element): string[] {\n    let className = ''\n    switch (typeof el.className) {\n        case 'string':\n            className = el.className\n            break\n        // TODO: when is this ever used?\n        case 'object': // handle cases where className might be SVGAnimatedString or some other type\n            className =\n                (el.className && 'baseVal' in el.className ? (el.className as any).baseVal : null) ||\n                el.getAttribute('class') ||\n                ''\n            break\n        default:\n            className = ''\n    }\n\n    return splitClassString(className)\n}\n\nexport function makeSafeText(s: string | null | undefined): string | null {\n    if (isNullish(s)) {\n        return null\n    }\n\n    return (\n        trim(s)\n            // scrub potentially sensitive values\n            .split(/(\\s+)/)\n            .filter((s) => shouldCaptureValue(s))\n            .join('')\n            // normalize whitespace\n            .replace(/[\\r\\n]/g, ' ')\n            .replace(/[ ]+/g, ' ')\n            // truncate\n            .substring(0, 255)\n    )\n}\n\n/*\n * Get the direct text content of an element, protecting against sensitive data collection.\n * Concats textContent of each of the element's text node children; this avoids potential\n * collection of sensitive data that could happen if we used element.textContent and the\n * element had sensitive child elements, since element.textContent includes child content.\n * Scrubs values that look like they could be sensitive (i.e. cc or ssn number).\n * @param {Element} el - element to get the text of\n * @returns {string} the element's direct text content\n */\nexport function getSafeText(el: Element): string {\n    let elText = ''\n\n    if (shouldCaptureElement(el) && !isSensitiveElement(el) && el.childNodes && el.childNodes.length) {\n        each(el.childNodes, function (child) {\n            if (isTextNode(child) && child.textContent) {\n                elText += makeSafeText(child.textContent) ?? ''\n            }\n        })\n    }\n\n    return trim(elText)\n}\n\nexport function getEventTarget(e: Event): Element | null {\n    // https://developer.mozilla.org/en-US/docs/Web/API/Event/target#Compatibility_notes\n    if (isUndefined(e.target)) {\n        return (e.srcElement as Element) || null\n    } else {\n        if ((e.target as HTMLElement)?.shadowRoot) {\n            return (e.composedPath()[0] as Element) || null\n        }\n        return (e.target as Element) || null\n    }\n}\n\nexport const autocaptureCompatibleElements = ['a', 'button', 'form', 'input', 'select', 'textarea', 'label']\n\n/*\n if there is no config, then all elements are allowed\n if there is a config, and there is an allow list, then only elements in the allow list are allowed\n assumes that some other code is checking this element's parents\n */\nfunction checkIfElementTreePassesElementAllowList(\n    elements: Element[],\n    autocaptureConfig: AutocaptureConfig | undefined\n): boolean {\n    const allowlist = autocaptureConfig?.element_allowlist\n    if (isUndefined(allowlist)) {\n        // everything is allowed, when there is no allow list\n        return true\n    }\n\n    // check each element in the tree\n    // if any of the elements are in the allow list, then the tree is allowed\n    for (const el of elements) {\n        if (allowlist.some((elementType) => el.tagName.toLowerCase() === elementType)) {\n            return true\n        }\n    }\n\n    // otherwise there is an allow list and this element tree didn't match it\n    return false\n}\n\n/*\n if there is no selector list (i.e. it is undefined), then any elements matches\n if there is an empty list, then no elements match\n if there is a selector list, then check it against each element provided\n */\nfunction checkIfElementsMatchCSSSelector(elements: Element[], selectorList: string[] | undefined): boolean {\n    if (isUndefined(selectorList)) {\n        // everything is allowed, when there is no selector list\n        return true\n    }\n\n    for (const el of elements) {\n        if (selectorList.some((selector) => el.matches(selector))) {\n            return true\n        }\n    }\n\n    return false\n}\n\nexport function getParentElement(curEl: Element): Element | false {\n    const parentNode = curEl.parentNode\n    if (!parentNode || !isElementNode(parentNode)) return false\n    return parentNode\n}\n\nconst DEFAULT_CONTENT_IGNORELIST = ['next', 'previous', 'prev', '>', '<']\nconst MAX_CONTENT_IGNORELIST_ENTRIES = 10\n\ninterface ElementWithText {\n    safeText: string\n    ariaLabel: string\n}\n\nfunction shouldIgnoreByContent(\n    contentIgnorelist: boolean | string[] | undefined,\n    elementsWithText: ElementWithText[]\n): boolean {\n    if (contentIgnorelist === false || isUndefined(contentIgnorelist)) {\n        return false\n    }\n\n    let keywords: string[]\n    if (contentIgnorelist === true) {\n        keywords = DEFAULT_CONTENT_IGNORELIST\n    } else if (isArray(contentIgnorelist)) {\n        if (contentIgnorelist.length > MAX_CONTENT_IGNORELIST_ENTRIES) {\n            logger.error(\n                `[PostHog] content_ignorelist array cannot exceed ${MAX_CONTENT_IGNORELIST_ENTRIES} items. Use css_selector_ignorelist for more complex matching.`\n            )\n            return false\n        }\n        keywords = contentIgnorelist.map((k) => k.toLowerCase())\n    } else {\n        return false\n    }\n\n    return elementsWithText.some(({ safeText, ariaLabel }) => {\n        return keywords.some((keyword) => safeText.includes(keyword) || ariaLabel.includes(keyword))\n    })\n}\n\n// autocapture check will already filter for ph-no-capture,\n// but we include it here to protect against future changes accidentally removing that check\nconst DEFAULT_RAGE_CLICK_IGNORE_LIST = ['.ph-no-rageclick', '.ph-no-capture']\nexport function shouldCaptureRageclick(el: Element | null, _config: PostHogConfig['rageclick']) {\n    if (!window || cannotCheckForAutocapture(el)) {\n        return false\n    }\n\n    let selectorIgnoreList: string[] | boolean\n    let contentIgnorelist: boolean | string[] | undefined\n    if (isBoolean(_config)) {\n        selectorIgnoreList = _config ? DEFAULT_RAGE_CLICK_IGNORE_LIST : false\n        // For backward compatibility, don't enable content filtering for rageclick: true\n        contentIgnorelist = undefined\n    } else {\n        selectorIgnoreList = _config?.css_selector_ignorelist ?? DEFAULT_RAGE_CLICK_IGNORE_LIST\n        contentIgnorelist = _config?.content_ignorelist\n    }\n\n    if (selectorIgnoreList === false) {\n        return false\n    }\n\n    // Traverse DOM once and cache element data to avoid redundant calls to getSafeText\n    const { targetElementList } = getElementAndParentsForElement(el, false)\n    const elementsWithText: ElementWithText[] = targetElementList.map((element) => ({\n        safeText: getSafeText(element).toLowerCase(),\n        ariaLabel: element.getAttribute('aria-label')?.toLowerCase().trim() || '',\n    }))\n\n    if (shouldIgnoreByContent(contentIgnorelist, elementsWithText)) {\n        return false\n    }\n\n    // we don't capture if we match the ignore list\n    return !checkIfElementsMatchCSSSelector(targetElementList, selectorIgnoreList)\n}\n\nconst cannotCheckForAutocapture = (el: Element | null) => {\n    return !el || isTag(el, 'html') || !isElementNode(el)\n}\n\nconst getElementAndParentsForElement = (el: Element, captureOnAnyElement: false | true | undefined) => {\n    if (!window || cannotCheckForAutocapture(el)) {\n        return { parentIsUsefulElement: false, targetElementList: [] }\n    }\n\n    let parentIsUsefulElement = false\n    const targetElementList: Element[] = [el]\n    let curEl: Element = el\n    while (curEl.parentNode && !isTag(curEl, 'body')) {\n        // If element is a shadow root, we skip it\n        if (isDocumentFragment(curEl.parentNode)) {\n            targetElementList.push((curEl.parentNode as any).host)\n            curEl = (curEl.parentNode as any).host\n            continue\n        }\n        const parentNode = getParentElement(curEl)\n        if (!parentNode) break\n        if (captureOnAnyElement || autocaptureCompatibleElements.indexOf(parentNode.tagName.toLowerCase()) > -1) {\n            parentIsUsefulElement = true\n        } else {\n            const compStyles = window.getComputedStyle(parentNode)\n            if (compStyles && compStyles.getPropertyValue('cursor') === 'pointer') {\n                parentIsUsefulElement = true\n            }\n        }\n\n        targetElementList.push(parentNode)\n        curEl = parentNode\n    }\n    return { parentIsUsefulElement, targetElementList }\n}\n\n/*\n * Check whether a DOM event should be \"captured\" or if it may contain sensitive data\n * using a variety of heuristics.\n * @param {Element} el - element to check\n * @param {Event} event - event to check\n * @param {Object} autocaptureConfig - autocapture config\n * @param {boolean} captureOnAnyElement - whether to capture on any element, clipboard autocapture doesn't restrict to \"clickable\" elements\n * @param {string[]} allowedEventTypes - event types to capture, normally just 'click', but some autocapture types react to different events, some elements have fixed events (e.g., form has \"submit\")\n * @returns {boolean} whether the event should be captured\n */\nexport function shouldCaptureDomEvent(\n    el: Element,\n    event: Event,\n    autocaptureConfig: AutocaptureConfig | undefined = undefined,\n    captureOnAnyElement?: boolean,\n    allowedEventTypes?: string[]\n): boolean {\n    if (!window || cannotCheckForAutocapture(el)) {\n        return false\n    }\n\n    if (autocaptureConfig?.url_allowlist) {\n        // if the current URL is not in the allow list, don't capture\n        if (!checkForURLMatches(autocaptureConfig.url_allowlist)) {\n            return false\n        }\n    }\n\n    if (autocaptureConfig?.url_ignorelist) {\n        // if the current URL is in the ignore list, don't capture\n        if (checkForURLMatches(autocaptureConfig.url_ignorelist)) {\n            return false\n        }\n    }\n\n    if (autocaptureConfig?.dom_event_allowlist) {\n        const allowlist = autocaptureConfig.dom_event_allowlist\n        if (allowlist && !allowlist.some((eventType) => event.type === eventType)) {\n            return false\n        }\n    }\n\n    const { parentIsUsefulElement, targetElementList } = getElementAndParentsForElement(el, captureOnAnyElement)\n\n    if (!checkIfElementTreePassesElementAllowList(targetElementList, autocaptureConfig)) {\n        return false\n    }\n\n    if (!checkIfElementsMatchCSSSelector(targetElementList, autocaptureConfig?.css_selector_allowlist)) {\n        return false\n    }\n\n    const compStyles = window.getComputedStyle(el)\n    if (compStyles && compStyles.getPropertyValue('cursor') === 'pointer' && event.type === 'click') {\n        return true\n    }\n\n    const tag = el.tagName.toLowerCase()\n    switch (tag) {\n        case 'html':\n            return false\n        case 'form':\n            return (allowedEventTypes || ['submit']).indexOf(event.type) >= 0\n        case 'input':\n        case 'select':\n        case 'textarea':\n            return (allowedEventTypes || ['change', 'click']).indexOf(event.type) >= 0\n        default:\n            if (parentIsUsefulElement) return (allowedEventTypes || ['click']).indexOf(event.type) >= 0\n            return (\n                (allowedEventTypes || ['click']).indexOf(event.type) >= 0 &&\n                (autocaptureCompatibleElements.indexOf(tag) > -1 || el.getAttribute('contenteditable') === 'true')\n            )\n    }\n}\n\n/*\n * Check whether a DOM element should be \"captured\" or if it may contain sensitive data\n * using a variety of heuristics.\n * @param {Element} el - element to check\n * @returns {boolean} whether the element should be captured\n */\nexport function shouldCaptureElement(el: Element): boolean {\n    for (let curEl = el; curEl.parentNode && !isTag(curEl, 'body'); curEl = curEl.parentNode as Element) {\n        const classes = getClassNames(curEl)\n        if (includes(classes, 'ph-sensitive') || includes(classes, 'ph-no-capture')) {\n            return false\n        }\n    }\n\n    if (includes(getClassNames(el), 'ph-include')) {\n        return true\n    }\n\n    // don't include hidden or password fields\n    const type = (el as HTMLInputElement).type || ''\n    if (isString(type)) {\n        // it's possible for el.type to be a DOM element if el is a form with a child input[name=\"type\"]\n        switch (type.toLowerCase()) {\n            case 'hidden':\n                return false\n            case 'password':\n                return false\n        }\n    }\n\n    // filter out data from fields that look like sensitive fields\n    const name = (el as HTMLInputElement).name || el.id || ''\n    // See https://github.com/posthog/posthog-js/issues/165\n    // Under specific circumstances a bug caused .replace to be called on a DOM element\n    // instead of a string, removing the element from the page. Ensure this issue is mitigated.\n    if (isString(name)) {\n        // it's possible for el.name or el.id to be a DOM element if el is a form with a child input[name=\"name\"]\n        const sensitiveNameRegex =\n            /^cc|cardnum|ccnum|creditcard|csc|cvc|cvv|exp|pass|pwd|routing|seccode|securitycode|securitynum|socialsec|socsec|ssn/i\n        if (sensitiveNameRegex.test(name.replace(/[^a-zA-Z0-9]/g, ''))) {\n            return false\n        }\n    }\n\n    return true\n}\n\n/*\n * Check whether a DOM element is 'sensitive' and we should only capture limited data\n * @param {Element} el - element to check\n * @returns {boolean} whether the element should be captured\n */\nexport function isSensitiveElement(el: Element): boolean {\n    // don't send data from inputs or similar elements since there will always be\n    // a risk of clientside javascript placing sensitive data in attributes\n    const allowedInputTypes = ['button', 'checkbox', 'submit', 'reset']\n    if (\n        (isTag(el, 'input') && !allowedInputTypes.includes((el as HTMLInputElement).type)) ||\n        isTag(el, 'select') ||\n        isTag(el, 'textarea') ||\n        el.getAttribute('contenteditable') === 'true'\n    ) {\n        return true\n    }\n    return false\n}\n\n// Define the core pattern for matching credit card numbers\nconst coreCCPattern = `(4[0-9]{12}(?:[0-9]{3})?)|(5[1-5][0-9]{14})|(6(?:011|5[0-9]{2})[0-9]{12})|(3[47][0-9]{13})|(3(?:0[0-5]|[68][0-9])[0-9]{11})|((?:2131|1800|35[0-9]{3})[0-9]{11})`\n// Create the Anchored version of the regex by adding '^' at the start and '$' at the end\nconst anchoredCCRegex = new RegExp(`^(?:${coreCCPattern})$`)\n// The Unanchored version is essentially the core pattern, usable as is for partial matches\nconst unanchoredCCRegex = new RegExp(coreCCPattern)\n\n// Define the core pattern for matching SSNs with optional dashes\nconst coreSSNPattern = `\\\\d{3}-?\\\\d{2}-?\\\\d{4}`\n// Create the Anchored version of the regex by adding '^' at the start and '$' at the end\nconst anchoredSSNRegex = new RegExp(`^(${coreSSNPattern})$`)\n// The Unanchored version is essentially the core pattern itself, usable for partial matches\nconst unanchoredSSNRegex = new RegExp(`(${coreSSNPattern})`)\n\n/*\n * Check whether a string value should be \"captured\" or if it may contain sensitive data\n * using a variety of heuristics.\n * @param {string} value - string value to check\n * @param {boolean} anchorRegexes - whether to anchor the regexes to the start and end of the string\n * @returns {boolean} whether the element should be captured\n */\nexport function shouldCaptureValue(value: string, anchorRegexes = true): boolean {\n    if (isNullish(value)) {\n        return false\n    }\n\n    if (isString(value)) {\n        value = trim(value)\n\n        // check to see if input value looks like a credit card number\n        // see: https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9781449327453/ch04s20.html\n        const ccRegex = anchorRegexes ? anchoredCCRegex : unanchoredCCRegex\n        if (ccRegex.test((value || '').replace(/[- ]/g, ''))) {\n            return false\n        }\n\n        // check to see if input value looks like a social security number\n        const ssnRegex = anchorRegexes ? anchoredSSNRegex : unanchoredSSNRegex\n        if (ssnRegex.test(value)) {\n            return false\n        }\n    }\n\n    return true\n}\n\n/*\n * Check whether an attribute name is an Angular style attr (either _ngcontent or _nghost)\n * These update on each build and lead to noise in the element chain\n * More details on the attributes here: https://angular.io/guide/view-encapsulation\n * @param {string} attributeName - string value to check\n * @returns {boolean} whether the element is an angular tag\n */\nexport function isAngularStyleAttr(attributeName: string): boolean {\n    if (isString(attributeName)) {\n        return attributeName.substring(0, 10) === '_ngcontent' || attributeName.substring(0, 7) === '_nghost'\n    }\n    return false\n}\n\n/*\n * Iterate through children of a target element looking for span tags\n * and return the text content of the span tags, separated by spaces,\n * along with the direct text content of the target element\n * @param {Element} target - element to check\n * @returns {string} text content of the target element and its child span tags\n */\nexport function getDirectAndNestedSpanText(target: Element): string {\n    let text = getSafeText(target)\n    text = `${text} ${getNestedSpanText(target)}`.trim()\n    return shouldCaptureValue(text) ? text : ''\n}\n\n/*\n * Iterate through children of a target element looking for span tags\n * and return the text content of the span tags, separated by spaces\n * @param {Element} target - element to check\n * @returns {string} text content of span tags\n */\nexport function getNestedSpanText(target: Element): string {\n    let text = ''\n    if (target && target.childNodes && target.childNodes.length) {\n        each(target.childNodes, function (child) {\n            if (child && child.tagName?.toLowerCase() === 'span') {\n                try {\n                    const spanText = getSafeText(child)\n                    text = `${text} ${spanText}`.trim()\n\n                    if (child.childNodes && child.childNodes.length) {\n                        text = `${text} ${getNestedSpanText(child)}`.trim()\n                    }\n                } catch (e) {\n                    logger.error('[AutoCapture]', e)\n                }\n            }\n        })\n    }\n    return text\n}\n\n/*\nBack in the day storing events in Postgres we use Elements for autocapture events.\nNow we're using elements_chain. We used to do this parsing/processing during ingestion.\nThis code is just copied over from ingestion, but we should optimize it\nto create elements_chain string directly.\n*/\nexport function getElementsChainString(elements: Properties[]): string {\n    return elementsToString(extractElements(elements))\n}\n\n// This interface is called 'Element' in plugin-scaffold https://github.com/PostHog/plugin-scaffold/blob/b07d3b879796ecc7e22deb71bf627694ba05386b/src/types.ts#L200\n// However 'Element' is a DOM Element when run in the browser, so we have to rename it\ninterface PHElement {\n    text?: string\n    tag_name?: string\n    href?: string\n    attr_id?: string\n    attr_class?: string[]\n    nth_child?: number\n    nth_of_type?: number\n    attributes?: Record<string, any>\n    event_id?: number\n    order?: number\n    group_id?: number\n}\n\nfunction escapeQuotes(input: string): string {\n    return input.replace(/\"|\\\\\"/g, '\\\\\"')\n}\n\nfunction elementsToString(elements: PHElement[]): string {\n    const ret = elements.map((element) => {\n        let el_string = ''\n        if (element.tag_name) {\n            el_string += element.tag_name\n        }\n        if (element.attr_class) {\n            element.attr_class.sort()\n            for (const single_class of element.attr_class) {\n                el_string += `.${single_class.replace(/\"/g, '')}`\n            }\n        }\n        const attributes: Record<string, any> = {\n            ...(element.text ? { text: element.text } : {}),\n            'nth-child': element.nth_child ?? 0,\n            'nth-of-type': element.nth_of_type ?? 0,\n            ...(element.href ? { href: element.href } : {}),\n            ...(element.attr_id ? { attr_id: element.attr_id } : {}),\n            ...element.attributes,\n        }\n        const sortedAttributes: Record<string, any> = {}\n        entries(attributes)\n            .sort(([a], [b]) => a.localeCompare(b))\n            .forEach(\n                ([key, value]) => (sortedAttributes[escapeQuotes(key.toString())] = escapeQuotes(value.toString()))\n            )\n        el_string += ':'\n        el_string += entries(sortedAttributes)\n            .map(([key, value]) => `${key}=\"${value}\"`)\n            .join('')\n        return el_string\n    })\n    return ret.join(';')\n}\n\nfunction extractElements(elements: Properties[]): PHElement[] {\n    return elements.map((el) => {\n        const response = {\n            text: el['$el_text']?.slice(0, 400),\n            tag_name: el['tag_name'],\n            href: el['attr__href']?.slice(0, 2048),\n            attr_class: extractAttrClass(el),\n            attr_id: el['attr__id'],\n            nth_child: el['nth_child'],\n            nth_of_type: el['nth_of_type'],\n            attributes: {} as { [id: string]: any },\n        }\n\n        entries(el)\n            .filter(([key]) => key.indexOf('attr__') === 0)\n            .forEach(([key, value]) => (response.attributes[key] = value))\n        return response\n    })\n}\n\nfunction extractAttrClass(el: Properties): PHElement['attr_class'] {\n    const attr_class = el['attr__class']\n    if (!attr_class) {\n        return undefined\n    } else if (isArray(attr_class)) {\n        return attr_class\n    } else {\n        return splitClassString(attr_class)\n    }\n}\n","import { addEventListener, each, extend } from './utils'\nimport {\n    autocaptureCompatibleElements,\n    getClassNames,\n    getDirectAndNestedSpanText,\n    getElementsChainString,\n    getEventTarget,\n    getSafeText,\n    isAngularStyleAttr,\n    isSensitiveElement,\n    makeSafeText,\n    shouldCaptureDomEvent,\n    shouldCaptureElement,\n    shouldCaptureRageclick,\n    shouldCaptureValue,\n    splitClassString,\n} from './autocapture-utils'\n\nimport RageClick from './extensions/rageclick'\nimport { AutocaptureConfig, EventName, Properties, RemoteConfig } from './types'\nimport { PostHog } from './posthog-core'\nimport { AUTOCAPTURE_DISABLED_SERVER_SIDE } from './constants'\n\nimport { isBoolean, isFunction, isNull, isObject } from '@posthog/core'\nimport { createLogger } from './utils/logger'\nimport { document, window } from './utils/globals'\nimport { convertToURL } from './utils/request-utils'\nimport { isDocumentFragment, isElementNode, isTag, isTextNode } from './utils/element-utils'\nimport { includes } from '@posthog/core'\n\nconst COPY_AUTOCAPTURE_EVENT = '$copy_autocapture'\n\nconst logger = createLogger('[AutoCapture]')\n\nfunction limitText(length: number, text: string): string {\n    if (text.length > length) {\n        return text.slice(0, length) + '...'\n    }\n    return text\n}\n\nexport function getAugmentPropertiesFromElement(elem: Element): Properties {\n    const shouldCaptureEl = shouldCaptureElement(elem)\n    if (!shouldCaptureEl) {\n        return {}\n    }\n\n    const props: Properties = {}\n\n    each(elem.attributes, function (attr: Attr) {\n        if (attr.name && attr.name.indexOf('data-ph-capture-attribute') === 0) {\n            const propertyKey = attr.name.replace('data-ph-capture-attribute-', '')\n            const propertyValue = attr.value\n            if (propertyKey && propertyValue && shouldCaptureValue(propertyValue)) {\n                props[propertyKey] = propertyValue\n            }\n        }\n    })\n\n    return props\n}\n\nexport function previousElementSibling(el: Element): Element | null {\n    if (el.previousElementSibling) {\n        return el.previousElementSibling\n    }\n    let _el: Element | null = el\n    do {\n        _el = _el.previousSibling as Element | null // resolves to ChildNode->Node, which is Element's parent class\n    } while (_el && !isElementNode(_el))\n    return _el\n}\n\nexport function getDefaultProperties(eventType: string): Properties {\n    return {\n        $event_type: eventType,\n        $ce_version: 1,\n    }\n}\n\nexport function getPropertiesFromElement(\n    elem: Element,\n    maskAllAttributes: boolean,\n    maskText: boolean,\n    elementAttributeIgnorelist: string[] | undefined\n): Properties {\n    const tag_name = elem.tagName.toLowerCase()\n    const props: Properties = {\n        tag_name: tag_name,\n    }\n    if (autocaptureCompatibleElements.indexOf(tag_name) > -1 && !maskText) {\n        if (tag_name.toLowerCase() === 'a' || tag_name.toLowerCase() === 'button') {\n            props['$el_text'] = limitText(1024, getDirectAndNestedSpanText(elem))\n        } else {\n            props['$el_text'] = limitText(1024, getSafeText(elem))\n        }\n    }\n\n    const classes = getClassNames(elem)\n    if (classes.length > 0)\n        props['classes'] = classes.filter(function (c) {\n            return c !== ''\n        })\n\n    // capture the deny list here because this not-a-class class makes it tricky to use this.config in the function below\n    each(elem.attributes, function (attr: Attr) {\n        // Only capture attributes we know are safe\n        if (isSensitiveElement(elem) && ['name', 'id', 'class', 'aria-label'].indexOf(attr.name) === -1) return\n\n        if (elementAttributeIgnorelist?.includes(attr.name)) return\n\n        if (!maskAllAttributes && shouldCaptureValue(attr.value) && !isAngularStyleAttr(attr.name)) {\n            let value = attr.value\n            if (attr.name === 'class') {\n                // html attributes can _technically_ contain linebreaks,\n                // but we're very intolerant of them in the class string,\n                // so we strip them.\n                value = splitClassString(value).join(' ')\n            }\n            props['attr__' + attr.name] = limitText(1024, value)\n        }\n    })\n\n    let nthChild = 1\n    let nthOfType = 1\n    let currentElem: Element | null = elem\n    while ((currentElem = previousElementSibling(currentElem))) {\n        // eslint-disable-line no-cond-assign\n        nthChild++\n        if (currentElem.tagName === elem.tagName) {\n            nthOfType++\n        }\n    }\n    props['nth_child'] = nthChild\n    props['nth_of_type'] = nthOfType\n\n    return props\n}\n\nexport function autocapturePropertiesForElement(\n    target: Element,\n    {\n        e,\n        maskAllElementAttributes,\n        maskAllText,\n        elementAttributeIgnoreList,\n        elementsChainAsString,\n    }: {\n        e: Event\n        maskAllElementAttributes: boolean\n        maskAllText: boolean\n        elementAttributeIgnoreList?: string[] | undefined\n        elementsChainAsString: boolean\n    }\n): { props: Properties; explicitNoCapture?: boolean } {\n    const targetElementList = [target]\n    let curEl = target\n    while (curEl.parentNode && !isTag(curEl, 'body')) {\n        if (isDocumentFragment(curEl.parentNode)) {\n            targetElementList.push((curEl.parentNode as any).host)\n            curEl = (curEl.parentNode as any).host\n            continue\n        }\n        targetElementList.push(curEl.parentNode as Element)\n        curEl = curEl.parentNode as Element\n    }\n\n    const elementsJson: Properties[] = []\n    const autocaptureAugmentProperties: Properties = {}\n    let href: string | false = false\n    let explicitNoCapture = false\n\n    each(targetElementList, (el) => {\n        const shouldCaptureEl = shouldCaptureElement(el)\n\n        // if the element or a parent element is an anchor tag\n        // include the href as a property\n        if (el.tagName.toLowerCase() === 'a') {\n            href = el.getAttribute('href')\n            href = shouldCaptureEl && href && shouldCaptureValue(href) && href\n        }\n\n        // allow users to programmatically prevent capturing of elements by adding class 'ph-no-capture'\n        const classes = getClassNames(el)\n        if (includes(classes, 'ph-no-capture')) {\n            explicitNoCapture = true\n        }\n\n        elementsJson.push(\n            getPropertiesFromElement(el, maskAllElementAttributes, maskAllText, elementAttributeIgnoreList)\n        )\n\n        const augmentProperties = getAugmentPropertiesFromElement(el)\n        extend(autocaptureAugmentProperties, augmentProperties)\n    })\n\n    if (explicitNoCapture) {\n        return { props: {}, explicitNoCapture }\n    }\n\n    if (!maskAllText) {\n        // if the element is a button or anchor tag get the span text from any\n        // children and include it as/with the text property on the parent element\n        if (target.tagName.toLowerCase() === 'a' || target.tagName.toLowerCase() === 'button') {\n            elementsJson[0]['$el_text'] = getDirectAndNestedSpanText(target)\n        } else {\n            elementsJson[0]['$el_text'] = getSafeText(target)\n        }\n    }\n\n    let externalHref: string | undefined\n    if (href) {\n        elementsJson[0]['attr__href'] = href\n        const hrefHost = convertToURL(href)?.host\n        const locationHost = window?.location?.host\n        if (hrefHost && locationHost && hrefHost !== locationHost) {\n            externalHref = href\n        }\n    }\n\n    const props = extend(\n        getDefaultProperties(e.type),\n        // Sending \"$elements\" is deprecated. Only one client on US cloud uses this.\n        !elementsChainAsString ? { $elements: elementsJson } : {},\n        // Always send $elements_chain, as it's needed downstream in site app filtering\n        { $elements_chain: getElementsChainString(elementsJson) },\n        elementsJson[0]?.['$el_text'] ? { $el_text: elementsJson[0]?.['$el_text'] } : {},\n        externalHref && e.type === 'click' ? { $external_click_url: externalHref } : {},\n        autocaptureAugmentProperties\n    )\n\n    return { props }\n}\n\nexport class Autocapture {\n    instance: PostHog\n    _initialized: boolean = false\n    _isDisabledServerSide: boolean | null = null\n    _elementSelectors: Set<string> | null\n    rageclicks: RageClick\n    _elementsChainAsString = false\n\n    constructor(instance: PostHog) {\n        this.instance = instance\n        this.rageclicks = new RageClick(instance.config.rageclick)\n        this._elementSelectors = null\n    }\n\n    private get _config(): AutocaptureConfig {\n        const config = isObject(this.instance.config.autocapture) ? this.instance.config.autocapture : {}\n        // precompile the regex\n        config.url_allowlist = config.url_allowlist?.map((url) => new RegExp(url))\n        config.url_ignorelist = config.url_ignorelist?.map((url) => new RegExp(url))\n        return config\n    }\n\n    _addDomEventHandlers(): void {\n        if (!this.isBrowserSupported()) {\n            logger.info('Disabling Automatic Event Collection because this browser is not supported')\n            return\n        }\n\n        if (!window || !document) {\n            return\n        }\n\n        const handler = (e: Event) => {\n            e = e || window?.event\n            try {\n                this._captureEvent(e)\n            } catch (error) {\n                logger.error('Failed to capture event', error)\n            }\n        }\n\n        addEventListener(document, 'submit', handler, { capture: true })\n        addEventListener(document, 'change', handler, { capture: true })\n        addEventListener(document, 'click', handler, { capture: true })\n\n        if (this._config.capture_copied_text) {\n            const copiedTextHandler = (e: Event) => {\n                e = e || window?.event\n                this._captureEvent(e, COPY_AUTOCAPTURE_EVENT)\n            }\n\n            addEventListener(document, 'copy', copiedTextHandler, { capture: true })\n            addEventListener(document, 'cut', copiedTextHandler, { capture: true })\n        }\n    }\n\n    public startIfEnabled() {\n        if (this.isEnabled && !this._initialized) {\n            this._addDomEventHandlers()\n            this._initialized = true\n        }\n    }\n\n    public onRemoteConfig(response: RemoteConfig) {\n        if (response.elementsChainAsString) {\n            this._elementsChainAsString = response.elementsChainAsString\n        }\n\n        // NOTE: Unlike other extensions (heatmaps, web-vitals, etc.), we intentionally\n        // DO NOT guard against missing autocapture_opt_out key here. Autocapture uses\n        // a \"wait for server, then enable unless explicitly opted out\" model:\n        // - Before remote config: autocapture disabled (isEnabled returns false)\n        // - After remote config: enabled unless autocapture_opt_out is explicitly true\n        // Missing/undefined key  !!undefined = false  autocapture enabled\n        // This is intentional and different from opt-in features like heatmaps.\n        if (this.instance.persistence) {\n            this.instance.persistence.register({\n                [AUTOCAPTURE_DISABLED_SERVER_SIDE]: !!response['autocapture_opt_out'],\n            })\n        }\n        // store this in-memory in case persistence is disabled\n        this._isDisabledServerSide = !!response['autocapture_opt_out']\n        this.startIfEnabled()\n    }\n\n    public setElementSelectors(selectors: Set<string>): void {\n        this._elementSelectors = selectors\n    }\n\n    public getElementSelectors(element: Element | null): string[] | null {\n        const elementSelectors: string[] = []\n\n        this._elementSelectors?.forEach((selector) => {\n            const matchedElements = document?.querySelectorAll(selector)\n            matchedElements?.forEach((matchedElement: Element) => {\n                if (element === matchedElement) {\n                    elementSelectors.push(selector)\n                }\n            })\n        })\n\n        return elementSelectors\n    }\n\n    public get isEnabled(): boolean {\n        const persistedServerDisabled = this.instance.persistence?.props[AUTOCAPTURE_DISABLED_SERVER_SIDE]\n        const memoryDisabled = this._isDisabledServerSide\n\n        if (isNull(memoryDisabled) && !isBoolean(persistedServerDisabled) && !this.instance._shouldDisableFlags()) {\n            // We only enable if we know that the server has not disabled it (unless /flags is disabled)\n            return false\n        }\n\n        const disabledServer = this._isDisabledServerSide ?? !!persistedServerDisabled\n        const disabledClient = !this.instance.config.autocapture\n        return !disabledClient && !disabledServer\n    }\n\n    private _captureEvent(e: Event, eventName: EventName = '$autocapture'): boolean | void {\n        if (!this.isEnabled) {\n            return\n        }\n\n        /*** Don't mess with this code without running IE8 tests on it ***/\n        let target = getEventTarget(e)\n        if (isTextNode(target)) {\n            // defeat Safari bug (see: http://www.quirksmode.org/js/events_properties.html)\n            target = (target.parentNode || null) as Element | null\n        }\n\n        if (eventName === '$autocapture' && e.type === 'click' && e instanceof MouseEvent) {\n            if (\n                !!this.instance.config.rageclick &&\n                this.rageclicks?.isRageClick(e.clientX, e.clientY, e.timeStamp || new Date().getTime())\n            ) {\n                if (shouldCaptureRageclick(target, this.instance.config.rageclick)) {\n                    this._captureEvent(e, '$rageclick')\n                }\n            }\n        }\n\n        const isCopyAutocapture = eventName === COPY_AUTOCAPTURE_EVENT\n        if (\n            target &&\n            shouldCaptureDomEvent(\n                target,\n                e,\n                this._config,\n                // mostly this method cares about the target element, but in the case of copy events,\n                // we want some of the work this check does without insisting on the target element's type\n                isCopyAutocapture,\n                // we also don't want to restrict copy checks to clicks,\n                // so we pass that knowledge in here, rather than add the logic inside the check\n                isCopyAutocapture ? ['copy', 'cut'] : undefined\n            )\n        ) {\n            const { props, explicitNoCapture } = autocapturePropertiesForElement(target, {\n                e,\n                maskAllElementAttributes: this.instance.config.mask_all_element_attributes,\n                maskAllText: this.instance.config.mask_all_text,\n                elementAttributeIgnoreList: this._config.element_attribute_ignorelist,\n                elementsChainAsString: this._elementsChainAsString,\n            })\n\n            if (explicitNoCapture) {\n                return false\n            }\n\n            const elementSelectors = this.getElementSelectors(target)\n            if (elementSelectors && elementSelectors.length > 0) {\n                props['$element_selectors'] = elementSelectors\n            }\n\n            if (eventName === COPY_AUTOCAPTURE_EVENT) {\n                // you can't read the data from the clipboard event,\n                // but you can guess that you can read it from the window's current selection\n                const selectedContent = makeSafeText(window?.getSelection()?.toString())\n                const clipType = (e as ClipboardEvent).type || 'clipboard'\n                if (!selectedContent) {\n                    return false\n                }\n                props['$selected_content'] = selectedContent\n                props['$copy_type'] = clipType\n            }\n\n            this.instance.capture(eventName, props)\n            return true\n        }\n    }\n\n    isBrowserSupported(): boolean {\n        return isFunction(document?.querySelectorAll)\n    }\n}\n","import { each } from './'\n\nimport { isArray, isFile, isUndefined } from '@posthog/core'\nimport { logger } from './logger'\nimport { document } from './globals'\n\nconst localDomains = ['localhost', '127.0.0.1']\n\n/**\n * IE11 doesn't support `new URL`\n * so we can create an anchor element and use that to parse the URL\n * there's a lot of overlap between HTMLHyperlinkElementUtils and URL\n * meaning useful properties like `pathname` are available on both\n */\nexport const convertToURL = (url: string): HTMLAnchorElement | null => {\n    const location = document?.createElement('a')\n    if (isUndefined(location)) {\n        return null\n    }\n\n    location.href = url\n    return location\n}\n\nexport const formDataToQuery = function (formdata: Record<string, any> | FormData, arg_separator = '&'): string {\n    let use_val: string\n    let use_key: string\n    const tph_arr: string[] = []\n\n    each(formdata, function (val: File | string | undefined, key: string | undefined) {\n        // the key might be literally the string undefined for e.g. if {undefined: 'something'}\n        if (isUndefined(val) || isUndefined(key) || key === 'undefined') {\n            return\n        }\n\n        use_val = encodeURIComponent(isFile(val) ? val.name : val.toString())\n        use_key = encodeURIComponent(key)\n        tph_arr[tph_arr.length] = use_key + '=' + use_val\n    })\n\n    return tph_arr.join(arg_separator)\n}\n\n// NOTE: Once we get rid of IE11/op_mini we can start using URLSearchParams\nexport const getQueryParam = function (url: string, param: string): string {\n    const withoutHash: string = url.split('#')[0] || ''\n\n    // Split only on the first ? to sort problem out for those with multiple ?s\n    // and then remove them\n    const queryParams: string = withoutHash.split(/\\?(.*)/)[1] || ''\n    const cleanedQueryParams = queryParams.replace(/^\\?+/g, '')\n\n    const queryParts = cleanedQueryParams.split('&')\n    let keyValuePair\n\n    for (let i = 0; i < queryParts.length; i++) {\n        const parts = queryParts[i].split('=')\n        if (parts[0] === param) {\n            keyValuePair = parts\n            break\n        }\n    }\n\n    if (!isArray(keyValuePair) || keyValuePair.length < 2) {\n        return ''\n    } else {\n        let result = keyValuePair[1]\n        try {\n            result = decodeURIComponent(result)\n        } catch {\n            logger.error('Skipping decoding for malformed query param: ' + result)\n        }\n        return result.replace(/\\+/g, ' ')\n    }\n}\n\n// replace any query params in the url with the provided mask value. Tries to keep the URL as instant as possible,\n// including preserving malformed text in most cases\nexport const maskQueryParams = function <T extends string | undefined>(\n    url: T,\n    maskedParams: string[] | undefined,\n    mask: string\n): T extends string ? string : undefined {\n    if (!url || !maskedParams || !maskedParams.length) {\n        return url as any\n    }\n\n    const splitHash = url.split('#')\n    const withoutHash: string = splitHash[0] || ''\n    const hash = splitHash[1]\n\n    const splitQuery: string[] = withoutHash.split('?')\n    const queryString: string = splitQuery[1]\n    const urlWithoutQueryAndHash: string = splitQuery[0]\n    const queryParts = (queryString || '').split('&')\n\n    // use an array of strings rather than an object to preserve ordering and duplicates\n    const paramStrings: string[] = []\n\n    for (let i = 0; i < queryParts.length; i++) {\n        const keyValuePair = queryParts[i].split('=')\n        if (!isArray(keyValuePair)) {\n            continue\n        } else if (maskedParams.includes(keyValuePair[0])) {\n            paramStrings.push(keyValuePair[0] + '=' + mask)\n        } else {\n            paramStrings.push(queryParts[i])\n        }\n    }\n\n    let result = urlWithoutQueryAndHash\n    if (queryString != null) {\n        result += '?' + paramStrings.join('&')\n    }\n    if (hash != null) {\n        result += '#' + hash\n    }\n\n    return result as any\n}\n\nexport const _getHashParam = function (hash: string, param: string): string | null {\n    const matches = hash.match(new RegExp(param + '=([^&]*)'))\n    return matches ? matches[1] : null\n}\n\nexport const isLocalhost = (): boolean => {\n    return localDomains.includes(location.hostname)\n}\n","import { window } from './globals'\n\n// When angular patches functions they pass the above `isNativeFunction` check (at least the MutationObserver)\nexport const isAngularZonePresent = (): boolean => {\n    return !!(window as any).Zone\n}\n\nexport const isDocument = (x: unknown): x is Document => {\n    // eslint-disable-next-line posthog-js/no-direct-document-check\n    return x instanceof Document\n}\n","/**\n * adapted from https://github.com/getsentry/sentry-javascript/blob/72751dacb88c5b970d8bac15052ee8e09b28fd5d/packages/browser-utils/src/getNativeImplementation.ts#L27\n * and https://github.com/PostHog/rrweb/blob/804380afbb1b9bed70b8792cb5a25d827f5c0cb5/packages/utils/src/index.ts#L31\n * after a number of performance reports from Angular users\n */\n\nimport { AssignableWindow } from './globals'\nimport { isAngularZonePresent } from './type-utils'\nimport { isFunction, isNativeFunction } from '@posthog/core'\nimport { logger } from './logger'\n\ninterface NativeImplementationsCache {\n    MutationObserver: typeof MutationObserver\n}\n\nconst cachedImplementations: Partial<NativeImplementationsCache> = {}\n\nexport function getNativeImplementation<T extends keyof NativeImplementationsCache>(\n    name: T,\n    assignableWindow: AssignableWindow\n): NativeImplementationsCache[T] {\n    const cached = cachedImplementations[name]\n    if (cached) {\n        return cached\n    }\n\n    let impl = assignableWindow[name] as NativeImplementationsCache[T]\n\n    if (isNativeFunction(impl) && !isAngularZonePresent()) {\n        return (cachedImplementations[name] = impl.bind(assignableWindow) as NativeImplementationsCache[T])\n    }\n\n    const document = assignableWindow.document\n    if (document && isFunction(document.createElement)) {\n        try {\n            const sandbox = document.createElement('iframe')\n            sandbox.hidden = true\n            document.head.appendChild(sandbox)\n            const contentWindow = sandbox.contentWindow\n            if (contentWindow && (contentWindow as any)[name]) {\n                impl = (contentWindow as any)[name] as NativeImplementationsCache[T]\n            }\n            document.head.removeChild(sandbox)\n        } catch (e) {\n            // Could not create sandbox iframe, just use assignableWindow.xxx\n            logger.warn(`Could not create sandbox iframe for ${name} check, bailing to assignableWindow.${name}: `, e)\n        }\n    }\n\n    // Sanity check: This _should_ not happen, but if it does, we just skip caching...\n    // This can happen e.g. in tests where fetch may not be available in the env, or similar.\n    if (!impl || !isFunction(impl)) {\n        return impl\n    }\n\n    return (cachedImplementations[name] = impl.bind(assignableWindow) as NativeImplementationsCache[T])\n}\n\nexport function getNativeMutationObserverImplementation(assignableWindow: AssignableWindow): typeof MutationObserver {\n    return getNativeImplementation('MutationObserver', assignableWindow)\n}\n","import { assignableWindow, LazyLoadedDeadClicksAutocaptureInterface } from '../utils/globals'\nimport { PostHog } from '../posthog-core'\nimport { isNull, isNumber, isUndefined } from '@posthog/core'\nimport { autocaptureCompatibleElements, getEventTarget } from '../autocapture-utils'\nimport { DeadClickCandidate, DeadClicksAutoCaptureConfig, Properties } from '../types'\nimport { autocapturePropertiesForElement } from '../autocapture'\nimport { isElementInToolbar, isElementNode, isTag } from '../utils/element-utils'\nimport { getNativeMutationObserverImplementation } from '../utils/prototype-utils'\nimport { addEventListener } from '../utils'\n\nfunction asClick(event: MouseEvent): DeadClickCandidate | null {\n    const eventTarget = getEventTarget(event)\n    if (eventTarget) {\n        return {\n            node: eventTarget,\n            originalEvent: event,\n            timestamp: Date.now(),\n        }\n    }\n    return null\n}\n\nfunction hasModifierKey(event: MouseEvent): boolean {\n    return event.ctrlKey || event.metaKey || event.altKey || event.shiftKey\n}\n\nfunction checkTimeout(value: number | undefined, thresholdMs: number) {\n    return isNumber(value) && value >= thresholdMs\n}\n\nclass LazyLoadedDeadClicksAutocapture implements LazyLoadedDeadClicksAutocaptureInterface {\n    private _mutationObserver: MutationObserver | undefined\n    private _lastMutation: number | undefined\n    private _lastSelectionChanged: number | undefined\n    private _clicks: DeadClickCandidate[] = []\n    private _checkClickTimer: number | undefined\n    private _config: Required<DeadClicksAutoCaptureConfig>\n    private _onCapture: (click: DeadClickCandidate, properties: Properties) => void\n\n    private _defaultConfig = (defaultOnCapture: (click: DeadClickCandidate, properties: Properties) => void) => ({\n        element_attribute_ignorelist: [],\n        scroll_threshold_ms: 100,\n        selection_change_threshold_ms: 100,\n        mutation_threshold_ms: 2500,\n        capture_clicks_with_modifier_keys: false,\n        __onCapture: defaultOnCapture,\n    })\n\n    private _asRequiredConfig(providedConfig?: DeadClicksAutoCaptureConfig): Required<DeadClicksAutoCaptureConfig> {\n        const defaultConfig = this._defaultConfig(providedConfig?.__onCapture || this._captureDeadClick.bind(this))\n        return {\n            element_attribute_ignorelist:\n                providedConfig?.element_attribute_ignorelist ?? defaultConfig.element_attribute_ignorelist,\n            scroll_threshold_ms: providedConfig?.scroll_threshold_ms ?? defaultConfig.scroll_threshold_ms,\n            selection_change_threshold_ms:\n                providedConfig?.selection_change_threshold_ms ?? defaultConfig.selection_change_threshold_ms,\n            mutation_threshold_ms: providedConfig?.mutation_threshold_ms ?? defaultConfig.mutation_threshold_ms,\n            capture_clicks_with_modifier_keys:\n                providedConfig?.capture_clicks_with_modifier_keys ?? defaultConfig.capture_clicks_with_modifier_keys,\n            __onCapture: defaultConfig.__onCapture,\n        }\n    }\n\n    constructor(\n        readonly instance: PostHog,\n        config?: DeadClicksAutoCaptureConfig\n    ) {\n        this._config = this._asRequiredConfig(config)\n        this._onCapture = this._config.__onCapture\n    }\n\n    start(observerTarget: Node) {\n        this._startClickObserver()\n        this._startScrollObserver()\n        this._startSelectionChangedObserver()\n        this._startMutationObserver(observerTarget)\n    }\n\n    private _startMutationObserver(observerTarget: Node) {\n        if (!this._mutationObserver) {\n            const NativeMutationObserver = getNativeMutationObserverImplementation(assignableWindow)\n            this._mutationObserver = new NativeMutationObserver((mutations) => {\n                this._onMutation(mutations)\n            })\n            this._mutationObserver.observe(observerTarget, {\n                attributes: true,\n                characterData: true,\n                childList: true,\n                subtree: true,\n            })\n        }\n    }\n\n    stop() {\n        this._mutationObserver?.disconnect()\n        this._mutationObserver = undefined\n        assignableWindow.removeEventListener('click', this._onClick)\n        assignableWindow.removeEventListener('scroll', this._onScroll, { capture: true })\n        assignableWindow.removeEventListener('selectionchange', this._onSelectionChange)\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    private _onMutation(_mutations: MutationRecord[]): void {\n        // we don't actually care about the content of the mutations, right now\n        this._lastMutation = Date.now()\n    }\n\n    private _startClickObserver() {\n        addEventListener(assignableWindow, 'click', this._onClick)\n    }\n\n    private _onClick = (event: Event): void => {\n        const click = asClick(event as MouseEvent)\n        if (!isNull(click) && !this._ignoreClick(click)) {\n            this._clicks.push(click)\n        }\n\n        if (this._clicks.length && isUndefined(this._checkClickTimer)) {\n            this._checkClickTimer = assignableWindow.setTimeout(() => {\n                this._checkClicks()\n            }, 1000)\n        }\n    }\n\n    // `capture: true` is required to get scroll events for other scrollable elements\n    // on the page, not just the window\n    // see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#usecapture\n    //\n    // `passive: true` is used to tell the browser that the scroll event handler will not call `preventDefault()`\n    // This allows the browser to optimize scrolling performance by not waiting for our handling of the scroll event\n    // see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#passive\n    private _startScrollObserver() {\n        addEventListener(assignableWindow, 'scroll', this._onScroll, { capture: true })\n    }\n\n    private _onScroll = (): void => {\n        const candidateNow = Date.now()\n        // very naive throttle\n        if (candidateNow % 50 === 0) {\n            // we can see many scrolls between scheduled checks,\n            // so we update scroll delay as we see them\n            // to avoid false positives\n            this._clicks.forEach((click) => {\n                if (isUndefined(click.scrollDelayMs)) {\n                    click.scrollDelayMs = candidateNow - click.timestamp\n                }\n            })\n        }\n    }\n\n    private _startSelectionChangedObserver() {\n        addEventListener(assignableWindow, 'selectionchange', this._onSelectionChange)\n    }\n\n    private _onSelectionChange = (): void => {\n        this._lastSelectionChanged = Date.now()\n    }\n\n    private _ignoreClick(click: DeadClickCandidate | null): boolean {\n        if (!click) {\n            return true\n        }\n\n        if (!this._config.capture_clicks_with_modifier_keys && hasModifierKey(click.originalEvent)) {\n            return true\n        }\n\n        if (isElementInToolbar(click.node)) {\n            return true\n        }\n\n        const alreadyClickedInLastSecond = this._clicks.some((c) => {\n            return c.node === click.node && Math.abs(c.timestamp - click.timestamp) < 1000\n        })\n\n        if (alreadyClickedInLastSecond) {\n            return true\n        }\n\n        if (\n            isTag(click.node, 'html') ||\n            !isElementNode(click.node) ||\n            autocaptureCompatibleElements.includes(click.node.tagName.toLowerCase())\n        ) {\n            return true\n        }\n\n        return false\n    }\n\n    private _checkClicks() {\n        if (!this._clicks.length) {\n            return\n        }\n\n        clearTimeout(this._checkClickTimer)\n        this._checkClickTimer = undefined\n\n        const clicksToCheck = this._clicks\n        this._clicks = []\n\n        for (const click of clicksToCheck) {\n            click.mutationDelayMs =\n                click.mutationDelayMs ??\n                (this._lastMutation && click.timestamp <= this._lastMutation\n                    ? this._lastMutation - click.timestamp\n                    : undefined)\n            click.absoluteDelayMs = Date.now() - click.timestamp\n            click.selectionChangedDelayMs =\n                this._lastSelectionChanged && click.timestamp <= this._lastSelectionChanged\n                    ? this._lastSelectionChanged - click.timestamp\n                    : undefined\n\n            const scrollTimeout = checkTimeout(click.scrollDelayMs, this._config.scroll_threshold_ms)\n            const selectionChangedTimeout = checkTimeout(\n                click.selectionChangedDelayMs,\n                this._config.selection_change_threshold_ms\n            )\n            const mutationTimeout = checkTimeout(click.mutationDelayMs, this._config.mutation_threshold_ms)\n            // we want to timeout eventually even if nothing else catches it...\n            // we leave a little longer than the maximum threshold to give the other checks a chance to catch it\n            const absoluteTimeout = checkTimeout(click.absoluteDelayMs, this._config.mutation_threshold_ms * 1.1)\n\n            const hadScroll = isNumber(click.scrollDelayMs) && click.scrollDelayMs < this._config.scroll_threshold_ms\n            const hadMutation =\n                isNumber(click.mutationDelayMs) && click.mutationDelayMs < this._config.mutation_threshold_ms\n            const hadSelectionChange =\n                isNumber(click.selectionChangedDelayMs) &&\n                click.selectionChangedDelayMs < this._config.selection_change_threshold_ms\n\n            if (hadScroll || hadMutation || hadSelectionChange) {\n                // ignore clicks that had a scroll or mutation\n                continue\n            }\n\n            if (scrollTimeout || mutationTimeout || absoluteTimeout || selectionChangedTimeout) {\n                this._onCapture(click, {\n                    $dead_click_last_mutation_timestamp: this._lastMutation,\n                    $dead_click_event_timestamp: click.timestamp,\n                    $dead_click_scroll_timeout: scrollTimeout,\n                    $dead_click_mutation_timeout: mutationTimeout,\n                    $dead_click_absolute_timeout: absoluteTimeout,\n                    $dead_click_selection_changed_timeout: selectionChangedTimeout,\n                })\n            } else if (click.absoluteDelayMs < this._config.mutation_threshold_ms) {\n                // keep waiting until next check\n                this._clicks.push(click)\n            }\n        }\n\n        if (this._clicks.length && isUndefined(this._checkClickTimer)) {\n            this._checkClickTimer = assignableWindow.setTimeout(() => {\n                this._checkClicks()\n            }, 1000)\n        }\n    }\n\n    private _captureDeadClick(click: DeadClickCandidate, properties: Properties) {\n        // TODO need to check safe and captur-able as with autocapture\n        // TODO autocaputure config\n        this.instance.capture(\n            '$dead_click',\n            {\n                ...properties,\n                ...autocapturePropertiesForElement(click.node, {\n                    e: click.originalEvent,\n                    maskAllElementAttributes: this.instance.config.mask_all_element_attributes,\n                    maskAllText: this.instance.config.mask_all_text,\n                    elementAttributeIgnoreList: this._config.element_attribute_ignorelist,\n                    // TRICKY: it appears that we were moving to elementsChainAsString, but the UI still depends on elements, so :shrug:\n                    elementsChainAsString: false,\n                }).props,\n                $dead_click_scroll_delay_ms: click.scrollDelayMs,\n                $dead_click_mutation_delay_ms: click.mutationDelayMs,\n                $dead_click_absolute_delay_ms: click.absoluteDelayMs,\n                $dead_click_selection_changed_delay_ms: click.selectionChangedDelayMs,\n            },\n            {\n                timestamp: new Date(click.timestamp),\n            }\n        )\n    }\n}\n\nassignableWindow.__PosthogExtensions__ = assignableWindow.__PosthogExtensions__ || {}\nassignableWindow.__PosthogExtensions__.initDeadClicksAutocapture = (ph, config) =>\n    new LazyLoadedDeadClicksAutocapture(ph, config)\n\nexport default LazyLoadedDeadClicksAutocapture\n","/*\n * Constants\n */\n\n/* PROPERTY KEYS */\n\n// This key is deprecated, but we want to check for it to see whether aliasing is allowed.\nexport const PEOPLE_DISTINCT_ID_KEY = '$people_distinct_id'\nexport const DISTINCT_ID = 'distinct_id'\nexport const DEVICE_ID = '$device_id'\nexport const ALIAS_ID_KEY = '__alias'\nexport const CAMPAIGN_IDS_KEY = '__cmpns'\nexport const EVENT_TIMERS_KEY = '__timers'\nexport const AUTOCAPTURE_DISABLED_SERVER_SIDE = '$autocapture_disabled_server_side'\nexport const HEATMAPS_ENABLED_SERVER_SIDE = '$heatmaps_enabled_server_side'\nexport const EXCEPTION_CAPTURE_ENABLED_SERVER_SIDE = '$exception_capture_enabled_server_side'\nexport const ERROR_TRACKING_SUPPRESSION_RULES = '$error_tracking_suppression_rules'\nexport const ERROR_TRACKING_CAPTURE_EXTENSION_EXCEPTIONS = '$error_tracking_capture_extension_exceptions'\nexport const WEB_VITALS_ENABLED_SERVER_SIDE = '$web_vitals_enabled_server_side'\nexport const DEAD_CLICKS_ENABLED_SERVER_SIDE = '$dead_clicks_enabled_server_side'\nexport const PRODUCT_TOURS_ENABLED_SERVER_SIDE = '$product_tours_enabled_server_side'\nexport const WEB_VITALS_ALLOWED_METRICS = '$web_vitals_allowed_metrics'\nexport const SESSION_RECORDING_REMOTE_CONFIG = '$session_recording_remote_config'\n// @deprecated can be removed along with eager loaded replay\nexport const SESSION_RECORDING_ENABLED_SERVER_SIDE = '$session_recording_enabled_server_side'\n// @deprecated can be removed along with eager loaded replay\nexport const CONSOLE_LOG_RECORDING_ENABLED_SERVER_SIDE = '$console_log_recording_enabled_server_side'\n// @deprecated can be removed along with eager loaded replay\nexport const SESSION_RECORDING_NETWORK_PAYLOAD_CAPTURE = '$session_recording_network_payload_capture'\n// @deprecated can be removed along with eager loaded replay\nexport const SESSION_RECORDING_MASKING = '$session_recording_masking'\n// @deprecated can be removed along with eager loaded replay\nexport const SESSION_RECORDING_CANVAS_RECORDING = '$session_recording_canvas_recording'\n// @deprecated can be removed along with eager loaded replay\nexport const SESSION_RECORDING_SAMPLE_RATE = '$replay_sample_rate'\n// @deprecated can be removed along with eager loaded replay\nexport const SESSION_RECORDING_MINIMUM_DURATION = '$replay_minimum_duration'\n// @deprecated can be removed along with eager loaded replay\nexport const SESSION_RECORDING_SCRIPT_CONFIG = '$replay_script_config'\nexport const SESSION_RECORDING_OVERRIDE_SAMPLING = '$replay_override_sampling'\nexport const SESSION_RECORDING_OVERRIDE_LINKED_FLAG = '$replay_override_linked_flag'\nexport const SESSION_RECORDING_OVERRIDE_URL_TRIGGER = '$replay_override_url_trigger'\nexport const SESSION_RECORDING_OVERRIDE_EVENT_TRIGGER = '$replay_override_event_trigger'\nexport const SESSION_ID = '$sesid'\nexport const SESSION_RECORDING_IS_SAMPLED = '$session_is_sampled'\nexport const SESSION_RECORDING_PAST_MINIMUM_DURATION = '$session_past_minimum_duration'\nexport const SESSION_RECORDING_URL_TRIGGER_ACTIVATED_SESSION = '$session_recording_url_trigger_activated_session'\nexport const SESSION_RECORDING_EVENT_TRIGGER_ACTIVATED_SESSION = '$session_recording_event_trigger_activated_session'\nexport const SESSION_RECORDING_FIRST_FULL_SNAPSHOT_TIMESTAMP = '$debug_first_full_snapshot_timestamp'\nexport const ENABLED_FEATURE_FLAGS = '$enabled_feature_flags'\nexport const PERSISTENCE_EARLY_ACCESS_FEATURES = '$early_access_features'\nexport const PERSISTENCE_FEATURE_FLAG_DETAILS = '$feature_flag_details'\nexport const STORED_PERSON_PROPERTIES_KEY = '$stored_person_properties'\nexport const STORED_GROUP_PROPERTIES_KEY = '$stored_group_properties'\nexport const SURVEYS = '$surveys'\nexport const SURVEYS_ACTIVATED = '$surveys_activated'\nexport const PRODUCT_TOURS_ACTIVATED = '$product_tours_activated'\nexport const CONVERSATIONS = '$conversations'\nexport const FLAG_CALL_REPORTED = '$flag_call_reported'\nexport const PERSISTENCE_FEATURE_FLAG_ERRORS = '$feature_flag_errors'\nexport const USER_STATE = '$user_state'\nexport const CLIENT_SESSION_PROPS = '$client_session_props'\nexport const CAPTURE_RATE_LIMIT = '$capture_rate_limit'\n\n/** @deprecated Delete this when INITIAL_PERSON_INFO has been around for long enough to ignore backwards compat */\nexport const INITIAL_CAMPAIGN_PARAMS = '$initial_campaign_params'\n/** @deprecated Delete this when INITIAL_PERSON_INFO has been around for long enough to ignore backwards compat */\nexport const INITIAL_REFERRER_INFO = '$initial_referrer_info'\nexport const INITIAL_PERSON_INFO = '$initial_person_info'\nexport const ENABLE_PERSON_PROCESSING = '$epp'\nexport const TOOLBAR_ID = '__POSTHOG_TOOLBAR__'\nexport const TOOLBAR_CONTAINER_CLASS = 'toolbar-global-fade-container'\n\n/**\n * PREVIEW - MAY CHANGE WITHOUT WARNING - DO NOT USE IN PRODUCTION\n * Sentinel value for distinct id, device id, session id. Signals that the server should generate the value\n * */\nexport const COOKIELESS_SENTINEL_VALUE = '$posthog_cookieless'\nexport const COOKIELESS_MODE_FLAG_PROPERTY = '$cookieless_mode'\n\nexport const WEB_EXPERIMENTS = '$web_experiments'\n\n// These are properties that are reserved and will not be automatically included in events\nexport const PERSISTENCE_RESERVED_PROPERTIES = [\n    PEOPLE_DISTINCT_ID_KEY,\n    ALIAS_ID_KEY,\n    CAMPAIGN_IDS_KEY,\n    EVENT_TIMERS_KEY,\n    SESSION_RECORDING_ENABLED_SERVER_SIDE,\n    HEATMAPS_ENABLED_SERVER_SIDE,\n    SESSION_ID,\n    ENABLED_FEATURE_FLAGS,\n    ERROR_TRACKING_SUPPRESSION_RULES,\n    USER_STATE,\n    PERSISTENCE_EARLY_ACCESS_FEATURES,\n    PERSISTENCE_FEATURE_FLAG_DETAILS,\n    STORED_GROUP_PROPERTIES_KEY,\n    STORED_PERSON_PROPERTIES_KEY,\n    SURVEYS,\n    FLAG_CALL_REPORTED,\n    PERSISTENCE_FEATURE_FLAG_ERRORS,\n    CLIENT_SESSION_PROPS,\n    CAPTURE_RATE_LIMIT,\n    INITIAL_CAMPAIGN_PARAMS,\n    INITIAL_REFERRER_INFO,\n    ENABLE_PERSON_PROCESSING,\n    INITIAL_PERSON_INFO,\n]\n\nexport const SURVEYS_REQUEST_TIMEOUT_MS = 10000\n\n/* Z-INDEX HIERARCHY: tours > surveys > support */\nexport const Z_INDEX_TOURS = 2147483646\nexport const Z_INDEX_SURVEYS = 2147483645\nexport const Z_INDEX_CONVERSATIONS = 2147483644\n"],"names":["win","window","undefined","global","globalThis","self","File","nativeForEach","Array","prototype","forEach","navigator","document","location","fetch","XMLHttpRequest","AbortController","userAgent","assignableWindow","includes","str","needle","indexOf","trim","nativeIsArray","isArray","ObjProto","Object","type_utils_hasOwnProperty","hasOwnProperty","type_utils_toString","toString","obj","call","isFunction","x","isNativeFunction","isUndefined","isString","isNull","isNullish","isNumber","isFormData","FormData","_createLogger","prefix","_temp","debugEnabled","logger","_log","level","POSTHOG_DEBUG","console","consoleLog","_len","arguments","length","args","_key","info","_len2","_key2","warn","_len3","_key3","error","_len4","_key4","critical","_len5","_key5","uninitializedWarning","methodName","createLogger","additionalPrefix","options","breaker","eachArray","iterator","thisArg","i","l","each","pair","entries","key","extend","source","prop","ownProps","keys","resArray","addEventListener","element","event","callback","capture","passive","isElementNode","el","nodeType","isTag","tag","tagName","toLowerCase","splitClassString","s","split","getClassNames","className","baseVal","getAttribute","getSafeText","elText","shouldCaptureElement","isSensitiveElement","childNodes","child","_makeSafeText","isTextNode","textContent","filter","shouldCaptureValue","join","replace","substring","autocaptureCompatibleElements","curEl","parentNode","classes","type","name","id","test","coreCCPattern","anchoredCCRegex","RegExp","unanchoredCCRegex","coreSSNPattern","anchoredSSNRegex","unanchoredSSNRegex","value","anchorRegexes","getDirectAndNestedSpanText","target","text","getNestedSpanText","_child$tagName","spanText","e","getElementsChainString","elements","ret","map","_element$nth_child","_element$nth_of_type","el_string","tag_name","attr_class","single_class","sort","attributes","_extends","nth_child","nth_of_type","href","attr_id","sortedAttributes","_ref2","_ref3","a","b","localeCompare","_ref4","escapeQuotes","_ref5","elementsToString","_el$$el_text","_el$attr__href","response","slice","extractAttrClass","_ref6","_ref7","extractElements","input","limitText","previousElementSibling","_el","previousSibling","getPropertiesFromElement","elem","maskAllAttributes","maskText","elementAttributeIgnorelist","props","c","attr","attributeName","nthChild","nthOfType","currentElem","autocapturePropertiesForElement","_ref","_elementsJson$","_elementsJson$2","maskAllElementAttributes","maskAllText","elementAttributeIgnoreList","targetElementList","push","host","externalHref","url","elementsJson","autocaptureAugmentProperties","explicitNoCapture","shouldCaptureEl","augmentProperties","propertyKey","propertyValue","getAugmentPropertiesFromElement","_convertToURL","_window$location","hrefHost","createElement","locationHost","$event_type","$ce_version","$elements","$elements_chain","$el_text","$external_click_url","isAngularZonePresent","Zone","cachedImplementations","getNativeMutationObserverImplementation","cached","impl","bind","sandbox","hidden","head","appendChild","contentWindow","removeChild","getNativeImplementation","asClick","_e$target","eventTarget","srcElement","shadowRoot","composedPath","node","originalEvent","timestamp","Date","now","checkTimeout","thresholdMs","LazyLoadedDeadClicksAutocapture","_asRequiredConfig","providedConfig","_providedConfig$eleme","_providedConfig$scrol","_providedConfig$selec","_providedConfig$mutat","_providedConfig$captu","defaultConfig","this","_defaultConfig","__onCapture","_captureDeadClick","element_attribute_ignorelist","scroll_threshold_ms","selection_change_threshold_ms","mutation_threshold_ms","capture_clicks_with_modifier_keys","constructor","instance","config","_clicks","defaultOnCapture","_onClick","click","_ignoreClick","_checkClickTimer","setTimeout","_checkClicks","_onScroll","candidateNow","scrollDelayMs","_onSelectionChange","_lastSelectionChanged","_config","_onCapture","start","observerTarget","_startClickObserver","_startScrollObserver","_startSelectionChangedObserver","_startMutationObserver","_mutationObserver","NativeMutationObserver","mutations","_onMutation","observe","characterData","childList","subtree","stop","_this$_mutationObserv","disconnect","removeEventListener","_mutations","_lastMutation","ctrlKey","metaKey","altKey","shiftKey","Element","closest","some","Math","abs","clearTimeout","clicksToCheck","_click$mutationDelayM","mutationDelayMs","absoluteDelayMs","selectionChangedDelayMs","scrollTimeout","selectionChangedTimeout","mutationTimeout","absoluteTimeout","hadScroll","hadMutation","hadSelectionChange","$dead_click_last_mutation_timestamp","$dead_click_event_timestamp","$dead_click_scroll_timeout","$dead_click_mutation_timeout","$dead_click_absolute_timeout","$dead_click_selection_changed_timeout","properties","mask_all_element_attributes","mask_all_text","$dead_click_scroll_delay_ms","$dead_click_mutation_delay_ms","$dead_click_absolute_delay_ms","$dead_click_selection_changed_delay_ms","__PosthogExtensions__","initDeadClicksAutocapture","ph"],"mappings":"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"}