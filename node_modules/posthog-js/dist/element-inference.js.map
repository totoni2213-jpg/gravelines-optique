{"version":3,"file":"element-inference.js","sources":["../../../node_modules/.pnpm/query-selector-shadow-dom@1.0.1/node_modules/query-selector-shadow-dom/src/querySelectorDeep.js","../../../node_modules/.pnpm/query-selector-shadow-dom@1.0.1/node_modules/query-selector-shadow-dom/src/normalize.js","../src/utils/globals.ts","../../core/dist/utils/type-utils.mjs","../../core/dist/utils/logger.mjs","../src/extensions/product-tours/element-inference.ts"],"sourcesContent":["import { normalizeSelector } from './normalize';\n\n/**\n* Finds first matching elements on the page that may be in a shadow root using a complex selector of n-depth\n*\n* Don't have to specify all shadow roots to button, tree is travered to find the correct element\n*\n* Example querySelectorAllDeep('downloads-item:nth-child(4) #remove');\n*\n* Example should work on chrome://downloads outputting the remove button inside of a download card component\n*\n* Example find first active download link element querySelectorDeep('#downloads-list .is-active a[href^=\"https://\"]');\n*\n* Another example querySelectorAllDeep('#downloads-list div#title-area + a');\ne.g.\n*/\nexport function querySelectorAllDeep(selector, root = document, allElements = null) {\n    return _querySelectorDeep(selector, true, root, allElements);\n}\n\nexport function querySelectorDeep(selector, root = document, allElements = null) {\n    return _querySelectorDeep(selector, false, root, allElements);\n}\n\nfunction _querySelectorDeep(selector, findMany, root, allElements = null) {\n    selector = normalizeSelector(selector);\n    let lightElement = root.querySelector(selector);\n\n    if (document.head.createShadowRoot || document.head.attachShadow) {\n        // no need to do any special if selector matches something specific in light-dom\n        if (!findMany && lightElement) {\n            return lightElement;\n        }\n\n        // split on commas because those are a logical divide in the operation\n        const selectionsToMake = splitByCharacterUnlessQuoted(selector, ',');\n\n        return selectionsToMake.reduce((acc, minimalSelector) => {\n            // if not finding many just reduce the first match\n            if (!findMany && acc) {\n                return acc;\n            }\n            // do best to support complex selectors and split the query\n            const splitSelector = splitByCharacterUnlessQuoted(minimalSelector\n                    //remove white space at start of selector\n                    .replace(/^\\s+/g, '')\n                    .replace(/\\s*([>+~]+)\\s*/g, '$1'), ' ')\n                    // filter out entry white selectors\n                    .filter((entry) => !!entry)\n                    // convert \"a > b\" to [\"a\", \"b\"]\n                    .map((entry) => splitByCharacterUnlessQuoted(entry, '>'));\n\n            const possibleElementsIndex = splitSelector.length - 1;\n            const lastSplitPart = splitSelector[possibleElementsIndex][splitSelector[possibleElementsIndex].length - 1];\n            const possibleElements = collectAllElementsDeep(lastSplitPart, root, allElements);\n            const findElements = findMatchingElement(splitSelector, possibleElementsIndex, root);\n            if (findMany) {\n                acc = acc.concat(possibleElements.filter(findElements));\n                return acc;\n            } else {\n                acc = possibleElements.find(findElements);\n                return acc || null;\n            }\n        }, findMany ? [] : null);\n\n\n    } else {\n        if (!findMany) {\n            return lightElement;\n        } else {\n            return root.querySelectorAll(selector);\n        }\n    }\n\n}\n\nfunction findMatchingElement(splitSelector, possibleElementsIndex, root) {\n    return (element) => {\n        let position = possibleElementsIndex;\n        let parent = element;\n        let foundElement = false;\n        while (parent && !isDocumentNode(parent)) {\n            let foundMatch = true;\n            if (splitSelector[position].length === 1) {\n                foundMatch = parent.matches(splitSelector[position]);\n            } else {\n                // selector is in the format \"a > b\"\n                // make sure a few parents match in order\n                const reversedParts = ([]).concat(splitSelector[position]).reverse();\n                let newParent = parent;\n                for (const part of reversedParts) {\n                    if (!newParent || !newParent.matches(part)) {\n                        foundMatch = false;\n                        break;\n                    }\n                    newParent = findParentOrHost(newParent, root);\n                }\n            }\n\n            if (foundMatch && position === 0) {\n                foundElement = true;\n                break;\n            }\n            if (foundMatch) {\n                position--;\n            }\n            parent = findParentOrHost(parent, root);\n        }\n        return foundElement;\n    };\n\n}\n\nfunction splitByCharacterUnlessQuoted(selector, character) {\n    return selector.match(/\\\\?.|^$/g).reduce((p, c) => {\n        if (c === '\"' && !p.sQuote) {\n            p.quote ^= 1;\n            p.a[p.a.length - 1] += c;\n        } else if (c === '\\'' && !p.quote) {\n            p.sQuote ^= 1;\n            p.a[p.a.length - 1] += c;\n\n        } else if (!p.quote && !p.sQuote && c === character) {\n            p.a.push('');\n        } else {\n            p.a[p.a.length - 1] += c;\n        }\n        return p;\n    }, { a: [''] }).a;\n}\n\n/**\n * Checks if the node is a document node or not.\n * @param {Node} node\n * @returns {node is Document | DocumentFragment}\n */\nfunction isDocumentNode(node) {\n    return node.nodeType === Node.DOCUMENT_FRAGMENT_NODE || node.nodeType === Node.DOCUMENT_NODE;\n}\n\nfunction findParentOrHost(element, root) {\n    const parentNode = element.parentNode;\n    return (parentNode && parentNode.host && parentNode.nodeType === 11) ? parentNode.host : parentNode === root ? null : parentNode;\n}\n\n/**\n * Finds all elements on the page, inclusive of those within shadow roots.\n * @param {string=} selector Simple selector to filter the elements by. e.g. 'a', 'div.main'\n * @return {!Array<string>} List of anchor hrefs.\n * @author ebidel@ (Eric Bidelman)\n * License Apache-2.0\n */\nexport function collectAllElementsDeep(selector = null, root, cachedElements = null) {\n    let allElements = [];\n\n    if (cachedElements) {\n        allElements = cachedElements;\n    } else {\n        const findAllElements = function(nodes) {\n            for (let i = 0; i < nodes.length; i++) {\n                const el = nodes[i];\n                allElements.push(el);\n                // If the element has a shadow root, dig deeper.\n                if (el.shadowRoot) {\n                    findAllElements(el.shadowRoot.querySelectorAll('*'));\n                }\n            }\n        };\n        if(root.shadowRoot) {\n            findAllElements(root.shadowRoot.querySelectorAll('*'));\n        }\n        findAllElements(root.querySelectorAll('*'));\n    }\n\n    return selector ? allElements.filter(el => el.matches(selector)) : allElements;\t}\n\n","/* istanbul ignore file */\n\n\n// normalize-selector-rev-02.js\n/*\n  author: kyle simpson (@getify)\n  original source: https://gist.github.com/getify/9679380\n\n  modified for tests by david kaye (@dfkaye)\n  21 march 2014\n\n  rev-02 incorporate kyle's changes 3/2/42014\n*/\n\nexport function normalizeSelector(sel) {\n  // save unmatched text, if any\n  function saveUnmatched() {\n    if (unmatched) {\n      // whitespace needed after combinator?\n      if (tokens.length > 0 && /^[~+>]$/.test(tokens[tokens.length - 1])) {\n        tokens.push(\" \");\n      }\n\n      // save unmatched text\n      tokens.push(unmatched);\n    }\n  }\n\n  var tokens = [],\n    match,\n    unmatched,\n    regex,\n    state = [0],\n    next_match_idx = 0,\n    prev_match_idx,\n    not_escaped_pattern = /(?:[^\\\\]|(?:^|[^\\\\])(?:\\\\\\\\)+)$/,\n    whitespace_pattern = /^\\s+$/,\n    state_patterns = [\n      /\\s+|\\/\\*|[\"'>~+[(]/g, // general\n      /\\s+|\\/\\*|[\"'[\\]()]/g, // [..] set\n      /\\s+|\\/\\*|[\"'[\\]()]/g, // (..) set\n      null, // string literal (placeholder)\n      /\\*\\//g, // comment\n    ];\n  sel = sel.trim();\n\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    unmatched = \"\";\n\n    regex = state_patterns[state[state.length - 1]];\n\n    regex.lastIndex = next_match_idx;\n    match = regex.exec(sel);\n\n    // matched text to process?\n    if (match) {\n      prev_match_idx = next_match_idx;\n      next_match_idx = regex.lastIndex;\n\n      // collect the previous string chunk not matched before this token\n      if (prev_match_idx < next_match_idx - match[0].length) {\n        unmatched = sel.substring(\n          prev_match_idx,\n          next_match_idx - match[0].length\n        );\n      }\n\n      // general, [ ] pair, ( ) pair?\n      if (state[state.length - 1] < 3) {\n        saveUnmatched();\n\n        // starting a [ ] pair?\n        if (match[0] === \"[\") {\n          state.push(1);\n        }\n        // starting a ( ) pair?\n        else if (match[0] === \"(\") {\n          state.push(2);\n        }\n        // starting a string literal?\n        else if (/^[\"']$/.test(match[0])) {\n          state.push(3);\n          state_patterns[3] = new RegExp(match[0], \"g\");\n        }\n        // starting a comment?\n        else if (match[0] === \"/*\") {\n          state.push(4);\n        }\n        // ending a [ ] or ( ) pair?\n        else if (/^[\\])]$/.test(match[0]) && state.length > 0) {\n          state.pop();\n        }\n        // handling whitespace or a combinator?\n        else if (/^(?:\\s+|[~+>])$/.test(match[0])) {\n          // need to insert whitespace before?\n          if (\n            tokens.length > 0 &&\n            !whitespace_pattern.test(tokens[tokens.length - 1]) &&\n            state[state.length - 1] === 0\n          ) {\n            // add normalized whitespace\n            tokens.push(\" \");\n          }\n\n          // case-insensitive attribute selector CSS L4\n          if (\n            state[state.length - 1] === 1 &&\n            tokens.length === 5 &&\n            tokens[2].charAt(tokens[2].length - 1) === \"=\"\n          ) {\n            tokens[4] = \" \" + tokens[4];\n          }\n\n          // whitespace token we can skip?\n          if (whitespace_pattern.test(match[0])) {\n            continue;\n          }\n        }\n\n        // save matched text\n        tokens.push(match[0]);\n      }\n      // otherwise, string literal or comment\n      else {\n        // save unmatched text\n        tokens[tokens.length - 1] += unmatched;\n\n        // unescaped terminator to string literal or comment?\n        if (not_escaped_pattern.test(tokens[tokens.length - 1])) {\n          // comment terminator?\n          if (state[state.length - 1] === 4) {\n            // ok to drop comment?\n            if (\n              tokens.length < 2 ||\n              whitespace_pattern.test(tokens[tokens.length - 2])\n            ) {\n              tokens.pop();\n            }\n            // otherwise, turn comment into whitespace\n            else {\n              tokens[tokens.length - 1] = \" \";\n            }\n\n            // handled already\n            match[0] = \"\";\n          }\n\n          state.pop();\n        }\n\n        // append matched text to existing token\n        tokens[tokens.length - 1] += match[0];\n      }\n    }\n    // otherwise, end of processing (no more matches)\n    else {\n      unmatched = sel.substr(next_match_idx);\n      saveUnmatched();\n\n      break;\n    }\n  }\n\n  return tokens.join(\"\").trim();\n}\n","import type { PostHog } from '../posthog-core'\nimport { SessionIdManager } from '../sessionid'\nimport {\n    DeadClicksAutoCaptureConfig,\n    ExternalIntegrationKind,\n    Properties,\n    RemoteConfig,\n    SiteAppLoader,\n    SessionStartReason,\n} from '../types'\nimport type {\n    ConversationsRemoteConfig,\n    GetMessagesResponse,\n    GetTicketsOptions,\n    GetTicketsResponse,\n    MarkAsReadResponse,\n    RestoreFromTokenResponse,\n    RequestRestoreLinkResponse,\n    SendMessageResponse,\n    UserProvidedTraits,\n} from '../posthog-conversations-types'\n// only importing types here, so won't affect the bundle\n// eslint-disable-next-line posthog-js/no-external-replay-imports\nimport type { SessionRecordingStatus, TriggerType } from '../extensions/replay/external/triggerMatching'\nimport { eventWithTime } from '../extensions/replay/types/rrweb-types'\nimport { ErrorTracking } from '@posthog/core'\n\n/*\n * Global helpers to protect access to browser globals in a way that is safer for different targets\n * like DOM, SSR, Web workers etc.\n *\n * NOTE: Typically we want the \"window\" but globalThis works for both the typical browser context as\n * well as other contexts such as the web worker context. Window is still exported for any bits that explicitly require it.\n * If in doubt - export the global you need from this file and use that as an optional value. This way the code path is forced\n * to handle the case where the global is not available.\n */\n\n// eslint-disable-next-line no-restricted-globals\nconst win: (Window & typeof globalThis) | undefined = typeof window !== 'undefined' ? window : undefined\n\nexport type AssignableWindow = Window &\n    typeof globalThis & {\n        /*\n         * Main PostHog instance\n         */\n        posthog: any\n\n        /*\n         * This is our contract between (potentially) lazily loaded extensions and the SDK\n         */\n        __PosthogExtensions__?: PostHogExtensions\n\n        /**\n         * When loading remote config, we assign it to this global configuration\n         * for ease of sharing it with the rest of the SDK\n         */\n        _POSTHOG_REMOTE_CONFIG?: Record<\n            string,\n            {\n                config: RemoteConfig\n                siteApps: SiteAppLoader[]\n            }\n        >\n\n        /**\n         * If this is set on the window, our logger will log to the console\n         * for ease of debugging. Used for testing purposes only.\n         *\n         * @see {Config.DEBUG} from config.ts\n         */\n        POSTHOG_DEBUG: any\n\n        // Exposed by the browser\n        doNotTrack: any\n\n        // See entrypoints/customizations.full.ts\n        posthogCustomizations: any\n\n        /**\n         * This is a legacy way to expose these functions, but we still need to support it for backwards compatibility\n         * Can be removed once we drop support for 1.161.1\n         *\n         * See entrypoints/exception-autocapture.ts\n         *\n         * @deprecated use `__PosthogExtensions__.errorWrappingFunctions` instead\n         */\n        posthogErrorWrappingFunctions: any\n\n        /**\n         * This is a legacy way to expose these functions, but we still need to support it for backwards compatibility\n         * Can be removed once we drop support for 1.161.1\n         *\n         * See entrypoints/posthog-recorder.ts\n         *\n         * @deprecated use `__PosthogExtensions__.rrweb` instead\n         */\n        rrweb: any\n\n        /**\n         * This is a legacy way to expose these functions, but we still need to support it for backwards compatibility\n         * Can be removed once we drop support for 1.161.1\n         *\n         * See entrypoints/posthog-recorder.ts\n         *\n         * @deprecated use `__PosthogExtensions__.rrwebConsoleRecord` instead\n         */\n        rrwebConsoleRecord: any\n\n        /**\n         * This is a legacy way to expose these functions, but we still need to support it for backwards compatibility\n         * Can be removed once we drop support for 1.161.1\n         *\n         * See entrypoints/posthog-recorder.ts\n         *\n         * @deprecated use `__PosthogExtensions__.getRecordNetworkPlugin` instead\n         */\n        getRecordNetworkPlugin: any\n\n        /**\n         * This is a legacy way to expose these functions, but we still need to support it for backwards compatibility\n         * Can be removed once we drop support for 1.161.1\n         *\n         * See entrypoints/web-vitals.ts\n         *\n         * @deprecated use `__PosthogExtensions__.postHogWebVitalsCallbacks` instead\n         */\n        postHogWebVitalsCallbacks: any\n\n        /**\n         * This is a legacy way to expose these functions, but we still need to support it for backwards compatibility\n         * Can be removed once we drop support for 1.161.1\n         *\n         * See entrypoints/tracing-headers.ts\n         *\n         * @deprecated use `__PosthogExtensions__.postHogTracingHeadersPatchFns` instead\n         */\n        postHogTracingHeadersPatchFns: any\n\n        /**\n         * This is a legacy way to expose these functions, but we still need to support it for backwards compatibility\n         * Can be removed once we drop support for 1.161.1\n         *\n         * See entrypoints/surveys.ts\n         *\n         * @deprecated use `__PosthogExtensions__.generateSurveys` instead\n         */\n        extendPostHogWithSurveys: any\n\n        /*\n         * These are used to handle our toolbar state.\n         * @see {Toolbar} from extensions/toolbar.ts\n         */\n        ph_load_toolbar: any\n        ph_load_editor: any\n        ph_toolbar_state: any\n    } & Record<`__$$ph_site_app_${string}`, any>\n\n/**\n * This is our contract between (potentially) lazily loaded extensions and the SDK\n * changes to this interface can be breaking changes for users of the SDK\n */\n\nexport type ExternalExtensionKind = 'intercom-integration' | 'crisp-chat-integration'\n\nexport type PostHogExtensionKind =\n    | 'toolbar'\n    | 'exception-autocapture'\n    | 'web-vitals'\n    | 'web-vitals-with-attribution'\n    | 'recorder'\n    | 'lazy-recorder'\n    | 'tracing-headers'\n    | 'surveys'\n    | 'logs'\n    | 'conversations'\n    | 'product-tours'\n    | 'dead-clicks-autocapture'\n    | 'remote-config'\n    | ExternalExtensionKind\n\nexport interface LazyLoadedSessionRecordingInterface {\n    start: (startReason?: SessionStartReason) => void\n    stop: () => void\n    sessionId: string\n    status: SessionRecordingStatus\n    onRRwebEmit: (rawEvent: eventWithTime) => void\n    log: (message: string, level: 'log' | 'warn' | 'error') => void\n    sdkDebugProperties: Properties\n    overrideLinkedFlag: () => void\n    overrideSampling: () => void\n    overrideTrigger: (triggerType: TriggerType) => void\n    isStarted: boolean\n    tryAddCustomEvent(tag: string, payload: any): boolean\n}\n\nexport interface LazyLoadedDeadClicksAutocaptureInterface {\n    start: (observerTarget: Node) => void\n    stop: () => void\n}\n\nexport interface LazyLoadedConversationsInterface {\n    // Widget control\n    show: () => void\n    hide: () => void\n    isVisible: () => boolean\n\n    // Lifecycle\n    reset: () => void\n\n    // API methods\n    sendMessage: (message: string, userTraits?: UserProvidedTraits, newTicket?: boolean) => Promise<SendMessageResponse>\n    getMessages: (ticketId?: string, after?: string) => Promise<GetMessagesResponse>\n    markAsRead: (ticketId?: string) => Promise<MarkAsReadResponse>\n    getTickets: (options?: GetTicketsOptions) => Promise<GetTicketsResponse>\n    requestRestoreLink: (email: string) => Promise<RequestRestoreLinkResponse>\n    restoreFromToken: (restoreToken: string) => Promise<RestoreFromTokenResponse>\n    restoreFromUrlToken: () => Promise<RestoreFromTokenResponse | null>\n    getCurrentTicketId: () => string | null\n    getWidgetSessionId: () => string\n}\n\ninterface PostHogExtensions {\n    loadExternalDependency?: (\n        posthog: PostHog,\n        kind: PostHogExtensionKind,\n        callback: (error?: string | Event, event?: Event) => void\n    ) => void\n\n    loadSiteApp?: (posthog: PostHog, appUrl: string, callback: (error?: string | Event, event?: Event) => void) => void\n\n    errorWrappingFunctions?: {\n        wrapOnError: (captureFn: (props: ErrorTracking.ErrorProperties) => void) => () => void\n        wrapUnhandledRejection: (captureFn: (props: ErrorTracking.ErrorProperties) => void) => () => void\n        wrapConsoleError: (captureFn: (props: ErrorTracking.ErrorProperties) => void) => () => void\n    }\n    rrweb?: { record: any; version: string; wasMaxDepthReached?: () => boolean; resetMaxDepthState?: () => void }\n    rrwebPlugins?: { getRecordConsolePlugin: any; getRecordNetworkPlugin?: any }\n    generateSurveys?: (posthog: PostHog, isSurveysEnabled: boolean) => any | undefined\n    generateProductTours?: (posthog: PostHog, isEnabled: boolean) => any | undefined\n    logs?: {\n        initializeLogs?: (posthog: PostHog) => any | undefined\n    }\n    postHogWebVitalsCallbacks?: {\n        onLCP: (metric: any) => void\n        onCLS: (metric: any) => void\n        onFCP: (metric: any) => void\n        onINP: (metric: any) => void\n    }\n    /**\n     * @deprecated\n     *\n     * this was introduced briefly, it is now always a no-op and only kept for backwards compatibility\n     */\n    loadWebVitalsCallbacks?: (useAttribution?: boolean) => PostHogExtensions['postHogWebVitalsCallbacks']\n    tracingHeadersPatchFns?: {\n        _patchFetch: (hostnames: string[], distinctId: string, sessionManager?: SessionIdManager) => () => void\n        _patchXHR: (hostnames: string[], distinctId: string, sessionManager?: SessionIdManager) => () => void\n    }\n    initDeadClicksAutocapture?: (\n        ph: PostHog,\n        config: DeadClicksAutoCaptureConfig\n    ) => LazyLoadedDeadClicksAutocaptureInterface\n    integrations?: {\n        [K in ExternalIntegrationKind]?: { start: (posthog: PostHog) => void; stop: () => void }\n    }\n    initSessionRecording?: (ph: PostHog) => LazyLoadedSessionRecordingInterface\n    initConversations?: (config: ConversationsRemoteConfig, posthog: PostHog) => LazyLoadedConversationsInterface\n}\n\nconst global: typeof globalThis | undefined = typeof globalThis !== 'undefined' ? globalThis : win\n\n// React Native polyfills for posthog-js compatibility\nif (typeof self === 'undefined') {\n    ;(global as any).self = global\n}\nif (typeof File === 'undefined') {\n    ;(global as any).File = function () {}\n}\n\nexport const ArrayProto = Array.prototype\nexport const nativeForEach = ArrayProto.forEach\nexport const nativeIndexOf = ArrayProto.indexOf\n\nexport const navigator = global?.navigator\nexport const document = global?.document\nexport const location = global?.location\nexport const fetch = global?.fetch\nexport const XMLHttpRequest =\n    global?.XMLHttpRequest && 'withCredentials' in new global.XMLHttpRequest() ? global.XMLHttpRequest : undefined\nexport const AbortController = global?.AbortController\nexport const userAgent = navigator?.userAgent\nexport const assignableWindow: AssignableWindow = win ?? ({} as any)\n\nexport { win as window }\n","import { knownUnsafeEditableEvent } from \"../types.mjs\";\nimport { includes } from \"./string-utils.mjs\";\nconst nativeIsArray = Array.isArray;\nconst ObjProto = Object.prototype;\nconst type_utils_hasOwnProperty = ObjProto.hasOwnProperty;\nconst type_utils_toString = ObjProto.toString;\nconst isArray = nativeIsArray || function(obj) {\n    return '[object Array]' === type_utils_toString.call(obj);\n};\nconst isFunction = (x)=>'function' == typeof x;\nconst isNativeFunction = (x)=>isFunction(x) && -1 !== x.toString().indexOf('[native code]');\nconst isObject = (x)=>x === Object(x) && !isArray(x);\nconst isEmptyObject = (x)=>{\n    if (isObject(x)) {\n        for(const key in x)if (type_utils_hasOwnProperty.call(x, key)) return false;\n        return true;\n    }\n    return false;\n};\nconst isUndefined = (x)=>void 0 === x;\nconst isString = (x)=>'[object String]' == type_utils_toString.call(x);\nconst isEmptyString = (x)=>isString(x) && 0 === x.trim().length;\nconst isNull = (x)=>null === x;\nconst isNullish = (x)=>isUndefined(x) || isNull(x);\nconst isNumber = (x)=>'[object Number]' == type_utils_toString.call(x) && x === x;\nconst isPositiveNumber = (value)=>isNumber(value) && value > 0;\nconst isBoolean = (x)=>'[object Boolean]' === type_utils_toString.call(x);\nconst isFormData = (x)=>x instanceof FormData;\nconst isFile = (x)=>x instanceof File;\nconst isPlainError = (x)=>x instanceof Error;\nconst isKnownUnsafeEditableEvent = (x)=>includes(knownUnsafeEditableEvent, x);\nfunction isPrimitive(value) {\n    return null === value || 'object' != typeof value;\n}\nfunction isBuiltin(candidate, className) {\n    return Object.prototype.toString.call(candidate) === `[object ${className}]`;\n}\nfunction isError(candidate) {\n    switch(Object.prototype.toString.call(candidate)){\n        case '[object Error]':\n        case '[object Exception]':\n        case '[object DOMException]':\n        case '[object DOMError]':\n        case '[object WebAssembly.Exception]':\n            return true;\n        default:\n            return isInstanceOf(candidate, Error);\n    }\n}\nfunction isErrorEvent(event) {\n    return isBuiltin(event, 'ErrorEvent');\n}\nfunction isEvent(candidate) {\n    return !isUndefined(Event) && isInstanceOf(candidate, Event);\n}\nfunction isPlainObject(candidate) {\n    return isBuiltin(candidate, 'Object');\n}\nfunction isInstanceOf(candidate, base) {\n    try {\n        return candidate instanceof base;\n    } catch  {\n        return false;\n    }\n}\nconst yesLikeValues = [\n    true,\n    'true',\n    1,\n    '1',\n    'yes'\n];\nconst isYesLike = (val)=>includes(yesLikeValues, val);\nconst noLikeValues = [\n    false,\n    'false',\n    0,\n    '0',\n    'no'\n];\nconst isNoLike = (val)=>includes(noLikeValues, val);\nexport { type_utils_hasOwnProperty as hasOwnProperty, isArray, isBoolean, isBuiltin, isEmptyObject, isEmptyString, isError, isErrorEvent, isEvent, isFile, isFormData, isFunction, isKnownUnsafeEditableEvent, isNativeFunction, isNoLike, isNull, isNullish, isNumber, isObject, isPlainError, isPlainObject, isPositiveNumber, isPrimitive, isString, isUndefined, isYesLike, noLikeValues, yesLikeValues };\n","function createConsole(consoleLike = console) {\n    const lockedMethods = {\n        log: consoleLike.log.bind(consoleLike),\n        warn: consoleLike.warn.bind(consoleLike),\n        error: consoleLike.error.bind(consoleLike),\n        debug: consoleLike.debug.bind(consoleLike)\n    };\n    return lockedMethods;\n}\nconst _createLogger = (prefix, maybeCall, consoleLike)=>{\n    function _log(level, ...args) {\n        maybeCall(()=>{\n            const consoleMethod = consoleLike[level];\n            consoleMethod(prefix, ...args);\n        });\n    }\n    const logger = {\n        info: (...args)=>{\n            _log('log', ...args);\n        },\n        warn: (...args)=>{\n            _log('warn', ...args);\n        },\n        error: (...args)=>{\n            _log('error', ...args);\n        },\n        critical: (...args)=>{\n            consoleLike['error'](prefix, ...args);\n        },\n        createLogger: (additionalPrefix)=>_createLogger(`${prefix} ${additionalPrefix}`, maybeCall, consoleLike)\n    };\n    return logger;\n};\nconst passThrough = (fn)=>fn();\nfunction createLogger(prefix, maybeCall = passThrough) {\n    return _createLogger(prefix, maybeCall, createConsole());\n}\nexport { _createLogger, createLogger };\n","import { querySelectorAllDeep } from 'query-selector-shadow-dom'\nimport { window as _window } from '../../utils/globals'\nimport { createLogger, isArray, isUndefined } from '@posthog/core'\n\nconst window = _window as Window & typeof globalThis\nconst logger = createLogger('[Element Inference]')\n\n// this is copied directly from the main repo: /frontend/src/toolbar/utils.ts\n// TODO: once this is deployed, we can have the main repo reference this instead\nexport function elementIsVisible(element: HTMLElement, cache: WeakMap<HTMLElement, boolean>): boolean {\n    try {\n        const alreadyCached = cache.get(element)\n        if (!isUndefined(alreadyCached)) {\n            return alreadyCached\n        }\n\n        if (element.checkVisibility) {\n            const nativeIsVisible = element.checkVisibility({\n                checkOpacity: true,\n                checkVisibilityCSS: true,\n            })\n            cache.set(element, nativeIsVisible)\n            return nativeIsVisible\n        }\n\n        const style = window.getComputedStyle(element)\n        const isInvisible = style.display === 'none' || style.visibility === 'hidden' || parseFloat(style.opacity) === 0\n        if (isInvisible) {\n            cache.set(element, false)\n            return false\n        }\n\n        // Check parent chain for display/visibility\n        let parent = element.parentElement\n        while (parent) {\n            // Check cache first\n            const cached = cache.get(parent)\n            if (!isUndefined(cached)) {\n                if (!cached) {\n                    return false\n                }\n                // If cached as visible, skip to next parent\n                parent = parent.parentElement\n                continue\n            }\n\n            const parentStyle = window.getComputedStyle(parent)\n            const parentVisible = parentStyle.display !== 'none' && parentStyle.visibility !== 'hidden'\n\n            cache.set(parent, parentVisible)\n\n            if (!parentVisible) {\n                return false\n            }\n            parent = parent.parentElement\n        }\n\n        // Check if element has actual rendered dimensions\n        const rect = element.getBoundingClientRect()\n        const elementHasActualRenderedDimensions =\n            rect.width > 0 ||\n            rect.height > 0 ||\n            // Some elements might be 0x0 but still visible (e.g., inline elements with content)\n            element.getClientRects().length > 0\n        cache.set(element, elementHasActualRenderedDimensions)\n        return elementHasActualRenderedDimensions\n    } catch {\n        // if we can't get the computed style, we'll assume the element is visible\n        return true\n    }\n}\n\nexport interface SelectorGroup {\n    cardinality: number\n    cssSelectors: Array<{\n        css: string\n        offset: number\n    }>\n}\n\nexport interface AutoData {\n    notextGroups: SelectorGroup[]\n    textGroups: SelectorGroup[]\n}\n\nexport interface InferredSelector {\n    autoData: string\n    text: string | null\n    excludeText?: boolean\n    precision?: number\n}\n\nfunction getElementText(element: HTMLElement): string | null {\n    const text = element.innerText?.trim()\n    // anything higher than 250 chars -> prob not a good selector / button / target\n    if (!text || text.length > 250) {\n        return null\n    }\n    return text\n}\n\nfunction elementMatchesText(element: HTMLElement, text: string): boolean {\n    const elementText = getElementText(element)\n    return elementText?.toLowerCase() === text.toLowerCase()\n}\n\n// generator to query elements, filtering by text and visibility\nfunction* queryElements(\n    selector: string,\n    text: string | null,\n    visibilityCache: WeakMap<HTMLElement, boolean>\n): Generator<HTMLElement, void, undefined> {\n    let elements: HTMLElement[]\n\n    try {\n        elements = querySelectorAllDeep(selector) as unknown as HTMLElement[]\n    } catch {\n        return\n    }\n\n    for (const el of elements) {\n        const element = el as HTMLElement\n        if (text && !elementMatchesText(element, text)) {\n            continue\n        }\n        if (!elementIsVisible(element, visibilityCache)) {\n            continue\n        }\n        yield element\n    }\n}\n\n// could be inlined, but wanna keep lazy eval from queryElements\nfunction nth<T>(iterable: Iterable<T>, n: number): T | null {\n    let idx = 0\n    for (const item of iterable) {\n        if (idx === n) {\n            return item\n        }\n        idx++\n    }\n    return null\n}\n\n/**\n * if inferSelector is the sauce, this is the nugget\n *\n * find an element in the dom using the element inference data\n *\n * 1. try each group of selectors, starting with most specific (lowest cardinality)\n * 2. try each selector in the group - run the css query, go to offset\n * 3. \"vote\" for the element if it was found\n * 4. return early if any element gets majority votes\n * 5. return element w/ most votes\n */\nexport function findElement(selector: InferredSelector): HTMLElement | null {\n    try {\n        const autoData = JSON.parse(selector.autoData) as AutoData\n        if (!isArray(autoData?.textGroups) || !isArray(autoData?.notextGroups)) {\n            logger.error('Invalid autoData structure:', autoData)\n            return null\n        }\n        const { text, excludeText, precision = 1 } = selector\n\n        // excludeText -> user setting, usually if the target element\n        // has dynamic/localized text\n        const useText = text != null && !excludeText\n\n        // choose appropriate group + sort\n        const groups = (useText ? autoData.textGroups : autoData.notextGroups).sort(\n            (a, b) => a.cardinality - b.cardinality\n        )\n\n        if (groups.length === 0) {\n            return null\n        }\n\n        // precision controls how many groups to search\n        // 1 = strict (only most specific group), 0 = loose (all groups)\n        const maxGroups = Math.max(1, Math.ceil((1 - precision) * groups.length))\n\n        const visibilityCache = new WeakMap<HTMLElement, boolean>()\n\n        // try each selector group, starting w/ most specific (lowest cardinality)\n        for (let i = 0; i < maxGroups; i++) {\n            const group = groups[i]\n            const votes = new Map<HTMLElement, number>()\n            let winner: HTMLElement | null = null\n            let maxVotes = 0\n\n            // test each selector in the group\n            for (const { css, offset } of group.cssSelectors) {\n                // get matches, jump to offset to find our target\n                const element = nth(queryElements(css, useText ? text : null, visibilityCache), offset)\n\n                if (!element) {\n                    continue\n                }\n\n                // if we found something, this element gets a vote\n                const voteCount = (votes.get(element) ?? 0) + 1\n                votes.set(element, voteCount)\n\n                if (voteCount > maxVotes) {\n                    maxVotes = voteCount\n                    winner = element\n\n                    // break early if we have a majority\n                    if (voteCount >= Math.ceil(group.cssSelectors.length / 2)) {\n                        return winner\n                    }\n                }\n            }\n\n            if (winner) {\n                return winner\n            }\n        }\n\n        return null\n    } catch (error) {\n        logger.error('Error finding element:', error)\n        return null\n    }\n}\n\nexport function getElementPath(el: HTMLElement | null, depth = 4): string | null {\n    if (!el) {\n        return null\n    }\n    const parts: string[] = []\n    let current: HTMLElement | null = el\n\n    while (current && parts.length < depth && current.tagName !== 'BODY') {\n        let part = current.tagName.toLowerCase()\n        if (current.id) {\n            part += `#${current.id}`\n        } else if (current.classList.length) {\n            part += `.${current.classList[0]}`\n        }\n        parts.unshift(part)\n        current = current.parentElement\n    }\n\n    return parts.join(' > ')\n}\n"],"names":["querySelectorAllDeep","selector","root","allElements","document","findMany","sel","saveUnmatched","unmatched","tokens","length","test","push","match","regex","prev_match_idx","state","next_match_idx","not_escaped_pattern","whitespace_pattern","state_patterns","trim","lastIndex","exec","substr","substring","RegExp","pop","charAt","join","normalizeSelector","querySelector","head","createShadowRoot","attachShadow","splitByCharacterUnlessQuoted","reduce","acc","minimalSelector","splitSelector","replace","filter","entry","map","possibleElementsIndex","possibleElements","cachedElements","findAllElements","nodes","i","el","shadowRoot","querySelectorAll","matches","collectAllElementsDeep","findElements","element","position","parent","foundElement","isDocumentNode","foundMatch","reversedParts","concat","reverse","newParent","part","findParentOrHost","findMatchingElement","_querySelectorDeep","character","p","c","sQuote","quote","a","node","nodeType","Node","DOCUMENT_FRAGMENT_NODE","DOCUMENT_NODE","parentNode","host","win","window","undefined","global","globalThis","self","File","navigator","location","fetch","XMLHttpRequest","AbortController","userAgent","nativeIsArray","Array","isArray","type_utils_toString","Object","prototype","toString","obj","call","isUndefined","x","_createLogger","prefix","maybeCall","consoleLike","_log","level","_len","arguments","args","_key","consoleMethod","info","_len2","_key2","warn","_len3","_key3","error","_len4","_key4","critical","_len5","_key5","createLogger","additionalPrefix","_window","logger","fn","console","log","bind","debug","elementIsVisible","cache","alreadyCached","get","checkVisibility","nativeIsVisible","checkOpacity","checkVisibilityCSS","set","style","getComputedStyle","display","visibility","parseFloat","opacity","parentElement","cached","parentStyle","parentVisible","rect","getBoundingClientRect","elementHasActualRenderedDimensions","width","height","getClientRects","_unused","elementMatchesText","text","elementText","_element$innerText","innerText","getElementText","toLowerCase","queryElements","visibilityCache","elements","_unused2","nth","iterable","n","idx","item","findElement","autoData","JSON","parse","textGroups","notextGroups","excludeText","precision","useText","groups","sort","b","cardinality","maxGroups","Math","max","ceil","WeakMap","group","votes","Map","winner","maxVotes","css","offset","cssSelectors","_votes$get","voteCount","getElementPath","depth","parts","current","tagName","id","classList","unshift"],"mappings":"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","x_google_ignoreList":[0,1]}