{"version":3,"file":"posthog-conversations-types.js","sourceRoot":"","sources":["../../src/posthog-conversations-types.ts"],"names":[],"mappings":"","sourcesContent":["/**\n * Position of the widget on the screen\n */\nexport type WidgetPosition = 'bottom_left' | 'bottom_right' | 'top_left' | 'top_right'\n\n/**\n * Remote configuration for conversations from the PostHog server\n */\nexport interface ConversationsRemoteConfig {\n    /**\n     * Whether conversations are enabled for this team\n     * When true, the conversations API is available (posthog.conversations.*)\n     */\n    enabled: boolean\n\n    /**\n     * Whether the widget UI (button + chat panel) should be shown\n     * Only takes effect when enabled is true\n     * @default false\n     */\n    widgetEnabled?: boolean\n\n    /**\n     * Public token for authenticating conversations API requests\n     * This token is team-scoped and meant to be embedded in client code\n     */\n    token: string\n\n    /**\n     * Greeting text to show when widget is first opened\n     */\n    greetingText?: string\n\n    /**\n     * Primary color for the widget UI\n     */\n    color?: string\n\n    /**\n     * Placeholder text for the message input\n     */\n    placeholderText?: string\n\n    /**\n     * Whether to require email before starting a conversation\n     * @default false\n     */\n    requireEmail?: boolean\n\n    /**\n     * Whether to show the name field in the identification form\n     * @default true (when requireEmail is true)\n     */\n    collectName?: boolean\n\n    /**\n     * Title for the identification form\n     * @default \"Before we start...\"\n     */\n    identificationFormTitle?: string\n\n    /**\n     * Description for the identification form\n     * @default \"Please provide your details so we can help you better.\"\n     */\n    identificationFormDescription?: string\n\n    /**\n     * List of allowed domains where the widget should be shown.\n     * Supports wildcards like \"https://*.example.com\"\n     * Empty array or not present means show on all domains.\n     */\n    domains?: string[]\n\n    /**\n     * Position of the widget on the screen\n     * @default 'bottom_right'\n     */\n    widgetPosition?: WidgetPosition\n}\n\n/**\n * Author types for messages in a conversation\n */\nexport type MessageAuthorType = 'customer' | 'AI' | 'human'\n\n/**\n * TipTap mark types for inline formatting\n */\nexport interface TipTapMark {\n    type: 'bold' | 'italic' | 'underline' | 'strike' | 'code' | 'link'\n    attrs?: {\n        href?: string\n        target?: string\n        [key: string]: unknown\n    }\n}\n\n/**\n * TipTap node representing content in the document tree\n */\nexport interface TipTapNode {\n    type: string\n    attrs?: Record<string, unknown>\n    content?: TipTapNode[]\n    marks?: TipTapMark[]\n    text?: string\n}\n\n/**\n * TipTap document - the root node of rich content\n */\nexport interface TipTapDoc {\n    type: 'doc'\n    content?: TipTapNode[]\n}\n\n/**\n * A message in a conversation\n */\nexport interface Message {\n    /**\n     * Unique identifier for the message\n     */\n    id: string\n\n    /**\n     * The message content as plain text (fallback)\n     */\n    content: string\n\n    /**\n     * Rich content in TipTap JSON format (preferred for rendering)\n     * Falls back to `content` if missing or invalid\n     */\n    rich_content?: TipTapDoc\n\n    /**\n     * Type of the message author\n     */\n    author_type: MessageAuthorType\n\n    /**\n     * Display name of the message author\n     */\n    author_name?: string\n\n    /**\n     * ISO timestamp when the message was created\n     */\n    created_at: string\n\n    /**\n     * Whether this is an internal note (not shown to customer)\n     */\n    is_private: boolean\n}\n\n/**\n * Status of a support ticket\n */\nexport type TicketStatus = 'new' | 'open' | 'pending' | 'on_hold' | 'resolved'\n\n/**\n * A support ticket in the conversations system\n */\nexport interface Ticket {\n    /**\n     * Unique identifier for the ticket\n     */\n    id: string\n\n    /**\n     * Current status of the ticket\n     */\n    status: TicketStatus\n\n    /**\n     * Preview of the last message\n     */\n    last_message?: string\n\n    /**\n     * ISO timestamp of the last message\n     */\n    last_message_at?: string\n\n    /**\n     * Total number of messages in this ticket\n     */\n    message_count: number\n\n    /**\n     * ISO timestamp when the ticket was created\n     */\n    created_at: string\n\n    /**\n     * Array of messages (only present in detailed ticket view)\n     */\n    messages?: Message[]\n\n    /**\n     * Number of unread messages from the team\n     */\n    unread_count?: number\n}\n\n/**\n * Visual state of the conversations widget\n */\nexport type ConversationsWidgetState = 'open' | 'closed'\n\n/**\n * Response from sending a message\n */\nexport interface SendMessageResponse {\n    /**\n     * ID of the ticket this message belongs to\n     */\n    ticket_id: string\n\n    /**\n     * ID of the newly created message\n     */\n    message_id: string\n\n    /**\n     * Current status of the ticket\n     */\n    ticket_status: TicketStatus\n\n    /**\n     * ISO timestamp when the message was created\n     */\n    created_at: string\n\n    /**\n     * Number of unread messages from the team\n     * After customer sends a message, this is always 0\n     */\n    unread_count: number\n}\n\n/**\n * Response from fetching messages\n */\nexport interface GetMessagesResponse {\n    /**\n     * ID of the ticket\n     */\n    ticket_id: string\n\n    /**\n     * Current status of the ticket\n     */\n    ticket_status: TicketStatus\n\n    /**\n     * Array of messages\n     */\n    messages: Message[]\n\n    /**\n     * Whether there are more messages to fetch\n     */\n    has_more: boolean\n\n    /**\n     * Number of unread messages from the team\n     */\n    unread_count: number\n}\n\n/**\n * Response from marking messages as read\n */\nexport interface MarkAsReadResponse {\n    /**\n     * Whether the operation was successful\n     */\n    success: boolean\n\n    /**\n     * Number of unread messages (should be 0 after marking as read)\n     */\n    unread_count: number\n}\n\n/**\n * Options for fetching tickets list\n */\nexport interface GetTicketsOptions {\n    /**\n     * Filter by ticket status (e.g., 'open', 'closed')\n     */\n    status?: string\n\n    /**\n     * Number of tickets to return (default: 20)\n     */\n    limit?: number\n\n    /**\n     * Pagination offset (default: 0)\n     */\n    offset?: number\n}\n\n/**\n * Response from fetching tickets list\n */\nexport interface GetTicketsResponse {\n    /**\n     * Total count of tickets\n     */\n    count: number\n\n    /**\n     * Array of tickets\n     */\n    results: Ticket[]\n}\n\n/**\n * Payload for restoring ticket access from a one-time token\n */\nexport interface RestoreFromTokenPayload {\n    /**\n     * Opaque one-time restore token from email link\n     */\n    restore_token: string\n\n    /**\n     * Current browser widget session ID requesting restore\n     */\n    widget_session_id: string\n\n    /**\n     * Optional distinct ID for debugging/observability\n     */\n    distinct_id?: string\n\n    /**\n     * Optional current URL for backend observability\n     */\n    current_url?: string\n}\n\nexport type RestoreFromTokenStatus = 'success' | 'expired' | 'invalid' | 'used'\n\n/**\n * Response from restore token exchange endpoint\n */\nexport interface RestoreFromTokenResponse {\n    /**\n     * Restore result\n     */\n    status: RestoreFromTokenStatus\n\n    /**\n     * Canonical widget session ID to use after restore\n     */\n    widget_session_id?: string\n\n    /**\n     * Migrated ticket IDs, if any\n     */\n    migrated_ticket_ids?: string[]\n\n    /**\n     * Optional machine-readable backend code\n     */\n    code?: string\n}\n\n/**\n * Payload for requesting a self-service restore link email\n */\nexport interface RequestRestoreLinkPayload {\n    email: string\n    request_url: string\n}\n\n/**\n * Response from self-service restore link request\n */\nexport interface RequestRestoreLinkResponse {\n    ok: true\n}\n\n/**\n * User traits to send with messages\n */\nexport interface ConversationsTraits {\n    name?: string | null\n    email?: string | null\n    [key: string]: string | number | boolean | null | undefined\n}\n\n/**\n * User-provided identification data (collected via the widget form)\n */\nexport interface UserProvidedTraits {\n    name?: string\n    email?: string\n}\n\n/**\n * Session context captured when creating a new ticket\n */\nexport interface SessionContext {\n    /**\n     * URL to the session replay at the time the ticket was created\n     * Includes timestamp to jump to the exact moment\n     */\n    session_replay_url?: string\n\n    /**\n     * Page URL where the ticket was created\n     */\n    current_url?: string\n}\n\n/**\n * Payload for sending a message via the conversations API\n */\nexport interface SendMessagePayload {\n    /**\n     * Widget session ID for access control\n     */\n    widget_session_id: string\n\n    /**\n     * Distinct ID for linking to PostHog Person\n     */\n    distinct_id: string\n\n    /**\n     * The message content to send\n     */\n    message: string\n\n    /**\n     * User identification traits\n     */\n    traits: {\n        name: string | null\n        email: string | null\n    }\n\n    /**\n     * Ticket ID to send the message to (null to create a new ticket)\n     */\n    ticket_id: string | null\n\n    /**\n     * Session ID captured when creating a new ticket\n     * Stored as a separate queryable DB field\n     */\n    session_id?: string\n\n    /**\n     * Session context captured when creating a new ticket\n     * Stored in a JSONField for flexibility\n     */\n    session_context?: SessionContext\n}\n"]}