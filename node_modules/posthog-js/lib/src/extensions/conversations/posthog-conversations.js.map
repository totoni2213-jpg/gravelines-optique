{"version":3,"file":"posthog-conversations.js","sourceRoot":"","sources":["../../../../src/extensions/conversations/posthog-conversations.ts"],"names":[],"mappings":"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","sourcesContent":["import { PostHog } from '../../posthog-core'\nimport {\n    ConversationsRemoteConfig,\n    GetMessagesResponse,\n    GetTicketsOptions,\n    GetTicketsResponse,\n    MarkAsReadResponse,\n    RestoreFromTokenResponse,\n    RequestRestoreLinkResponse,\n    SendMessageResponse,\n    UserProvidedTraits,\n} from '../../posthog-conversations-types'\nimport { RemoteConfig } from '../../types'\nimport { assignableWindow, LazyLoadedConversationsInterface } from '../../utils/globals'\nimport { createLogger } from '../../utils/logger'\nimport { isNullish, isUndefined, isBoolean, isNull } from '@posthog/core'\n\nconst logger = createLogger('[Conversations]')\n\nexport type ConversationsManager = LazyLoadedConversationsInterface\n\nexport class PostHogConversations {\n    // This is set to undefined until the remote config is loaded\n    // then it's set to true if conversations are enabled\n    // or false if conversations are disabled in the project settings\n    private _isConversationsEnabled?: boolean = undefined\n    private _conversationsManager: LazyLoadedConversationsInterface | null = null\n    private _isInitializing: boolean = false\n    private _remoteConfig: ConversationsRemoteConfig | null = null\n\n    constructor(private _instance: PostHog) {}\n\n    onRemoteConfig(response: RemoteConfig) {\n        // Don't load conversations if disabled via config\n        if (this._instance.config.disable_conversations) {\n            return\n        }\n\n        const conversations = response['conversations']\n        if (isNullish(conversations)) {\n            return\n        }\n\n        // Handle both boolean and object response\n        if (isBoolean(conversations)) {\n            this._isConversationsEnabled = conversations\n        } else {\n            // It's a ConversationsRemoteConfig object\n            this._isConversationsEnabled = conversations.enabled\n            this._remoteConfig = conversations\n        }\n\n        this.loadIfEnabled()\n    }\n\n    reset(): void {\n        // Delegate cleanup to the lazy-loaded manager (which knows about persistence keys)\n        // If not loaded, there's nothing to reset anyway\n        this._conversationsManager?.reset()\n        this._conversationsManager = null\n\n        // Reset local state\n        this._isConversationsEnabled = undefined\n        this._remoteConfig = null\n    }\n\n    loadIfEnabled() {\n        if (this._conversationsManager) {\n            return\n        }\n        if (this._isInitializing) {\n            return\n        }\n        if (this._instance.config.disable_conversations) {\n            return\n        }\n        if (this._instance.config.cookieless_mode && this._instance.consent.isOptedOut()) {\n            return\n        }\n\n        const phExtensions = assignableWindow?.__PosthogExtensions__\n        if (!phExtensions) {\n            return\n        }\n\n        // Wait for remote config to load\n        if (isUndefined(this._isConversationsEnabled)) {\n            return\n        }\n\n        // Check if conversations are enabled\n        if (!this._isConversationsEnabled) {\n            return\n        }\n\n        // Check if we have the required config\n        if (!this._remoteConfig || !this._remoteConfig.token) {\n            logger.error('Conversations enabled but missing token in remote config.')\n            return\n        }\n\n        // Note: Domain check is done in ConversationsManager for widget rendering\n        // The conversations API is loaded regardless of domain restrictions\n\n        this._isInitializing = true\n\n        try {\n            const initConversations = phExtensions.initConversations\n            if (initConversations) {\n                // Conversations code is already loaded\n                this._completeInitialization(initConversations)\n                this._isInitializing = false\n                return\n            }\n\n            // If we reach here, conversations code is not loaded yet\n            const loadExternalDependency = phExtensions.loadExternalDependency\n            if (!loadExternalDependency) {\n                this._handleLoadError('PostHog loadExternalDependency extension not found.')\n                return\n            }\n\n            // Load the conversations bundle\n            loadExternalDependency(this._instance, 'conversations', (err) => {\n                if (err || !phExtensions.initConversations) {\n                    this._handleLoadError('Could not load conversations script', err)\n                } else {\n                    this._completeInitialization(phExtensions.initConversations)\n                }\n                this._isInitializing = false\n            })\n        } catch (e) {\n            this._handleLoadError('Error initializing conversations', e)\n            this._isInitializing = false\n        }\n    }\n\n    /** Helper to finalize conversations initialization */\n    private _completeInitialization(\n        initConversationsFn: (config: ConversationsRemoteConfig, posthog: PostHog) => LazyLoadedConversationsInterface\n    ): void {\n        if (!this._remoteConfig) {\n            logger.error('Cannot complete initialization: remote config is null')\n            return\n        }\n\n        try {\n            // Pass config and PostHog instance to the extension\n            this._conversationsManager = initConversationsFn(this._remoteConfig, this._instance)\n            logger.info('Conversations loaded successfully')\n        } catch (e) {\n            this._handleLoadError('Error completing conversations initialization', e)\n        }\n    }\n\n    /** Helper to handle initialization errors */\n    private _handleLoadError(message: string, error?: any): void {\n        logger.error(message, error)\n        this._conversationsManager = null\n        this._isInitializing = false\n    }\n\n    /**\n     * Show the conversations widget (button and chat panel)\n     */\n    show(): void {\n        if (!this._conversationsManager) {\n            logger.warn('Conversations not loaded yet.')\n            return\n        }\n        this._conversationsManager.show()\n    }\n\n    /**\n     * Hide the conversations widget completely (button and chat panel)\n     */\n    hide(): void {\n        if (!this._conversationsManager) {\n            return\n        }\n        this._conversationsManager.hide()\n    }\n\n    /**\n     * Check if conversations are available (enabled in remote config AND loaded)\n     * Use this to check if conversations API can be used.\n     */\n    isAvailable(): boolean {\n        return this._isConversationsEnabled === true && !isNull(this._conversationsManager)\n    }\n\n    /**\n     * Check if the widget is currently visible (rendered and shown)\n     */\n    isVisible(): boolean {\n        return this._conversationsManager?.isVisible() ?? false\n    }\n\n    /**\n     * Send a message programmatically\n     * Creates a new ticket if none exists or if newTicket is true\n     *\n     * @param message - The message text to send\n     * @param userTraits - Optional user identification data (name, email)\n     * @param newTicket - If true, forces creation of a new ticket (starts new conversation)\n     * @returns Promise with response or null if conversations not available yet\n     * @note Conversations must be available first (check with isAvailable())\n     *\n     * @example\n     * // Send to existing or create new conversation\n     * const response = await posthog.conversations.sendMessage('Hello!', {\n     *   name: 'John Doe',\n     *   email: 'john@example.com'\n     * })\n     *\n     * @example\n     * // Force creation of a new conversation/ticket\n     * const newConvo = await posthog.conversations.sendMessage('Start fresh', undefined, true)\n     */\n    async sendMessage(\n        message: string,\n        userTraits?: UserProvidedTraits,\n        newTicket?: boolean\n    ): Promise<SendMessageResponse | null> {\n        if (!this._conversationsManager) {\n            logger.warn('Conversations not available yet.')\n            return null\n        }\n        return this._conversationsManager.sendMessage(message, userTraits, newTicket)\n    }\n\n    /**\n     * Get messages for the current or specified ticket\n     *\n     * @param ticketId - Optional ticket ID (defaults to current active ticket)\n     * @param after - Optional ISO timestamp to fetch messages after\n     * @returns Promise with messages response or null if conversations not available yet\n     * @note Conversations must be available first (check with isAvailable())\n     *\n     * @example\n     * // Get messages for current ticket\n     * const messages = await posthog.conversations.getMessages()\n     *\n     * // Get messages for specific ticket\n     * const messages = await posthog.conversations.getMessages('ticket-uuid')\n     */\n    async getMessages(ticketId?: string, after?: string): Promise<GetMessagesResponse | null> {\n        if (!this._conversationsManager) {\n            logger.warn('Conversations not available yet.')\n            return null\n        }\n        return this._conversationsManager.getMessages(ticketId, after)\n    }\n\n    /**\n     * Mark messages as read for the current or specified ticket\n     *\n     * @param ticketId - Optional ticket ID (defaults to current active ticket)\n     * @returns Promise with response or null if conversations not available yet\n     * @note Conversations must be available first (check with isAvailable())\n     *\n     * @example\n     * await posthog.conversations.markAsRead()\n     */\n    async markAsRead(ticketId?: string): Promise<MarkAsReadResponse | null> {\n        if (!this._conversationsManager) {\n            logger.warn('Conversations not available yet.')\n            return null\n        }\n        return this._conversationsManager.markAsRead(ticketId)\n    }\n\n    /**\n     * Get list of tickets for the current widget session\n     *\n     * @param options - Optional filtering and pagination options\n     * @returns Promise with tickets response or null if conversations not available yet\n     * @note Conversations must be available first (check with isAvailable())\n     *\n     * @example\n     * const tickets = await posthog.conversations.getTickets({\n     *   limit: 10,\n     *   offset: 0,\n     *   status: 'open'\n     * })\n     */\n    async getTickets(options?: GetTicketsOptions): Promise<GetTicketsResponse | null> {\n        if (!this._conversationsManager) {\n            logger.warn('Conversations not available yet.')\n            return null\n        }\n        return this._conversationsManager.getTickets(options)\n    }\n\n    /**\n     * Request a restore link email for previous conversations.\n     *\n     * @param email - Email address associated with previous conversations\n     * @returns Promise with generic success response or null if conversations unavailable\n     */\n    async requestRestoreLink(email: string): Promise<RequestRestoreLinkResponse | null> {\n        if (!this._conversationsManager) {\n            logger.warn('Conversations not available yet.')\n            return null\n        }\n        return this._conversationsManager.requestRestoreLink(email)\n    }\n\n    /**\n     * Redeem a restore token and relink eligible tickets to this browser session.\n     *\n     * @param restoreToken - Opaque restore token from restore email link\n     * @returns Promise with restore status or null if conversations unavailable\n     */\n    async restoreFromToken(restoreToken: string): Promise<RestoreFromTokenResponse | null> {\n        if (!this._conversationsManager) {\n            logger.warn('Conversations not available yet.')\n            return null\n        }\n        return this._conversationsManager.restoreFromToken(restoreToken)\n    }\n\n    /**\n     * Parse and redeem `ph_conv_restore` token from the current URL.\n     *\n     * @returns Promise with restore status, or null when no token/conversations unavailable\n     */\n    async restoreFromUrlToken(): Promise<RestoreFromTokenResponse | null> {\n        if (!this._conversationsManager) {\n            logger.warn('Conversations not available yet.')\n            return null\n        }\n        return this._conversationsManager.restoreFromUrlToken()\n    }\n\n    /**\n     * Get the current active ticket ID\n     * Returns null if no conversation has been started yet or if not available\n     *\n     * @returns Ticket ID or null\n     * @note Safe to call before conversations are available, will return null\n     *\n     * @example\n     * const ticketId = posthog.conversations.getCurrentTicketId()\n     * if (ticketId) {\n     *   console.log('Current ticket ID:', ticketId)\n     * }\n     */\n    getCurrentTicketId(): string | null {\n        return this._conversationsManager?.getCurrentTicketId() ?? null\n    }\n\n    /**\n     * Get the widget session ID (persistent browser identifier)\n     * This ID is used for access control and stays the same across page loads\n     * Returns null if conversations not available yet\n     *\n     * @returns Session ID or null if not available\n     * @note Safe to call before conversations are available, will return null\n     *\n     * @example\n     * const sessionId = posthog.conversations.getWidgetSessionId()\n     * if (!sessionId) {\n     *   // Conversations not available yet\n     *   posthog.conversations.show()\n     * }\n     */\n    getWidgetSessionId(): string | null {\n        return this._conversationsManager?.getWidgetSessionId() ?? null\n    }\n}\n"]}