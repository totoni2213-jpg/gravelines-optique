{"version":3,"file":"rate-limiter.js","sourceRoot":"","sources":["../../src/rate-limiter.ts"],"names":[],"mappings":"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","sourcesContent":["import { CAPTURE_RATE_LIMIT } from './constants'\nimport type { PostHog } from './posthog-core'\nimport { RequestResponse } from './types'\nimport { createLogger } from './utils/logger'\n\nconst logger = createLogger('[RateLimiter]')\n\nconst ONE_MINUTE_IN_MILLISECONDS = 60 * 1000\nconst RATE_LIMIT_EVENT = '$$client_ingestion_warning'\nconst DEFAULT_EVENTS_PER_SECOND = 10\nconst BURST_LIMIT_MULTIPLIER = 10\n\ninterface CaptureResponse {\n    quota_limited?: string[]\n}\n\nexport class RateLimiter {\n    instance: PostHog\n    serverLimits: Record<string, number> = {}\n    lastEventRateLimited = false\n\n    constructor(instance: PostHog) {\n        this.instance = instance\n        this.lastEventRateLimited = this.clientRateLimitContext(true).isRateLimited\n    }\n\n    get captureEventsPerSecond(): number {\n        return this.instance.config.rate_limiting?.events_per_second || DEFAULT_EVENTS_PER_SECOND\n    }\n\n    get captureEventsBurstLimit(): number {\n        return Math.max(\n            this.instance.config.rate_limiting?.events_burst_limit ||\n                this.captureEventsPerSecond * BURST_LIMIT_MULTIPLIER,\n            this.captureEventsPerSecond\n        )\n    }\n\n    public clientRateLimitContext(checkOnly = false): {\n        isRateLimited: boolean\n        remainingTokens: number\n    } {\n        // This is primarily to prevent runaway loops from flooding capture with millions of events for a single user.\n        // It's as much for our protection as theirs.\n        const { captureEventsBurstLimit, captureEventsPerSecond } = this\n        const now = new Date().getTime()\n        const bucket = this.instance.persistence?.get_property(CAPTURE_RATE_LIMIT) ?? {\n            tokens: captureEventsBurstLimit,\n            last: now,\n        }\n\n        bucket.tokens += ((now - bucket.last) / 1000) * captureEventsPerSecond\n        bucket.last = now\n\n        if (bucket.tokens > captureEventsBurstLimit) {\n            bucket.tokens = captureEventsBurstLimit\n        }\n\n        const isRateLimited = bucket.tokens < 1\n\n        if (!isRateLimited && !checkOnly) {\n            bucket.tokens = Math.max(0, bucket.tokens - 1)\n        }\n\n        if (isRateLimited && !this.lastEventRateLimited && !checkOnly) {\n            this.instance.capture(\n                RATE_LIMIT_EVENT,\n                {\n                    $$client_ingestion_warning_message: `posthog-js client rate limited. Config is set to ${captureEventsPerSecond} events per second and ${captureEventsBurstLimit} events burst limit.`,\n                },\n                {\n                    skip_client_rate_limiting: true,\n                }\n            )\n        }\n\n        this.lastEventRateLimited = isRateLimited\n        this.instance.persistence?.set_property(CAPTURE_RATE_LIMIT, bucket)\n\n        return {\n            isRateLimited,\n            remainingTokens: bucket.tokens,\n        }\n    }\n\n    public isServerRateLimited(batchKey: string | undefined): boolean {\n        const retryAfter = this.serverLimits[batchKey || 'events'] || false\n\n        if (retryAfter === false) {\n            return false\n        }\n        return new Date().getTime() < retryAfter\n    }\n\n    public checkForLimiting = (httpResponse: RequestResponse): void => {\n        const text = httpResponse.text\n\n        if (!text || !text.length) {\n            return\n        }\n\n        try {\n            const response: CaptureResponse = JSON.parse(text)\n            const quotaLimitedProducts = response.quota_limited || []\n            quotaLimitedProducts.forEach((batchKey) => {\n                logger.info(`${batchKey || 'events'} is quota limited.`)\n                this.serverLimits[batchKey] = new Date().getTime() + ONE_MINUTE_IN_MILLISECONDS\n            })\n        } catch (e: any) {\n            logger.warn(`could not rate limit - continuing. Error: \"${e?.message}\"`, { text })\n            return\n        }\n    }\n}\n"]}