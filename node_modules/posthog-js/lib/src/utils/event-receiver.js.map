{"version":3,"file":"event-receiver.js","sourceRoot":"","sources":["../../../src/utils/event-receiver.ts"],"names":[],"mappings":"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","sourcesContent":["import { SurveyActionType, SurveyEventType, SurveyEventWithFilters } from '../posthog-surveys-types'\nimport { ActionMatcher } from '../extensions/surveys/action-matcher'\nimport { PostHog } from '../posthog-core'\nimport { CaptureResult } from '../types'\nimport { matchPropertyFilters } from './property-utils'\nimport { isUndefined } from '@posthog/core'\nimport { createLogger } from './logger'\n\n/**\n * Interface for items that can be triggered by events/actions.\n * Both Survey and ProductTour implement this interface.\n */\nexport interface EventTriggerable {\n    id: string\n    conditions?: {\n        events?: { repeatedActivation?: boolean; values: SurveyEventWithFilters[] } | null\n        cancelEvents?: { values: SurveyEventWithFilters[] } | null\n        actions?: { values: SurveyActionType[] } | null\n    } | null\n}\n\n/**\n * Abstract base class for receiving events and matching them to triggerable items.\n * Subclasses implement type-specific behavior for surveys and product tours.\n */\nexport abstract class EventReceiver<T extends EventTriggerable> {\n    // eventToItems is a mapping of event name to all the items that are activated by it\n    protected _eventToItems: Map<string, string[]>\n    // cancelEventToItems is a mapping of event name to all the items that should be cancelled by it\n    protected _cancelEventToItems: Map<string, string[]>\n    // actionToItems is a mapping of action name to all the items that are activated by it\n    protected readonly _actionToItems: Map<string, string[]>\n    // actionMatcher can look at CaptureResult payloads and match an event to its corresponding action.\n    protected _actionMatcher?: ActionMatcher | null\n    protected readonly _instance?: PostHog\n\n    constructor(instance: PostHog) {\n        this._instance = instance\n        this._eventToItems = new Map<string, string[]>()\n        this._cancelEventToItems = new Map<string, string[]>()\n        this._actionToItems = new Map<string, string[]>()\n    }\n\n    // Abstract methods for subclasses to implement\n    protected abstract _getActivatedKey(): string\n    protected abstract _getShownEventName(): string\n    protected abstract _getItems(callback: (items: T[]) => void): void\n    protected abstract _cancelPendingItem(itemId: string): void\n    protected abstract _getLogger(): ReturnType<typeof createLogger>\n    /** Check if item is permanently ineligible (e.g. completed/dismissed). Skip adding to activated list. */\n    protected abstract _isItemPermanentlyIneligible(itemId?: string): boolean\n\n    private _doesEventMatchFilter(\n        eventConfig: SurveyEventWithFilters | undefined,\n        eventPayload?: CaptureResult\n    ): boolean {\n        if (!eventConfig) {\n            return false\n        }\n\n        return matchPropertyFilters(eventConfig.propertyFilters, eventPayload?.properties)\n    }\n\n    private _buildEventToItemMap(items: T[], conditionField: SurveyEventType): Map<string, string[]> {\n        const map = new Map<string, string[]>()\n        items.forEach((item) => {\n            item.conditions?.[conditionField]?.values?.forEach((event) => {\n                if (event?.name) {\n                    const existing = map.get(event.name) || []\n                    existing.push(item.id)\n                    map.set(event.name, existing)\n                }\n            })\n        })\n        return map\n    }\n\n    /**\n     * build a map of (Event1) => [Item1, Item2, Item3]\n     * used for items that should be [activated|cancelled] by Event1\n     */\n    private _getMatchingItems(\n        eventName: string,\n        eventPayload: CaptureResult | undefined,\n        conditionField: SurveyEventType\n    ): T[] {\n        const itemIdMap = conditionField === SurveyEventType.Activation ? this._eventToItems : this._cancelEventToItems\n        const itemIds = itemIdMap.get(eventName)\n\n        let items: T[] = []\n        this._getItems((allItems) => {\n            items = allItems.filter((item) => itemIds?.includes(item.id))\n        })\n\n        return items.filter((item) => {\n            const eventConfig = item.conditions?.[conditionField]?.values?.find((e) => e.name === eventName)\n            return this._doesEventMatchFilter(eventConfig, eventPayload)\n        })\n    }\n\n    register(items: T[]): void {\n        if (isUndefined(this._instance?._addCaptureHook)) {\n            return\n        }\n\n        this._setupEventBasedItems(items)\n        this._setupActionBasedItems(items)\n    }\n\n    private _setupActionBasedItems(items: T[]) {\n        const actionBasedItems = items.filter(\n            (item: T) => item.conditions?.actions && item.conditions?.actions?.values?.length > 0\n        )\n\n        if (actionBasedItems.length === 0) {\n            return\n        }\n\n        if (this._actionMatcher == null) {\n            this._actionMatcher = new ActionMatcher(this._instance)\n            this._actionMatcher.init()\n            // match any actions to its corresponding item.\n            const matchActionToItem = (actionName: string) => {\n                this.onAction(actionName)\n            }\n\n            this._actionMatcher._addActionHook(matchActionToItem)\n        }\n\n        actionBasedItems.forEach((item) => {\n            if (\n                item.conditions &&\n                item.conditions?.actions &&\n                item.conditions?.actions?.values &&\n                item.conditions?.actions?.values?.length > 0\n            ) {\n                // register the known set of actions with\n                // the action-matcher so it can match\n                // events to actions\n                this._actionMatcher?.register(item.conditions.actions.values)\n\n                // maintain a mapping of (Action1) => [Item1, Item2, Item3]\n                // where Items 1-3 are all activated by Action1\n                item.conditions?.actions?.values?.forEach((action) => {\n                    if (action && action.name) {\n                        const knownItems: string[] | undefined = this._actionToItems.get(action.name)\n                        if (knownItems) {\n                            knownItems.push(item.id)\n                        }\n                        this._actionToItems.set(action.name, knownItems || [item.id])\n                    }\n                })\n            }\n        })\n    }\n\n    private _setupEventBasedItems(items: T[]) {\n        const eventBasedItems = items.filter(\n            (item: T) => item.conditions?.events && item.conditions?.events?.values?.length > 0\n        )\n\n        const itemsWithCancelEvents = items.filter(\n            (item: T) => item.conditions?.cancelEvents && item.conditions?.cancelEvents?.values?.length > 0\n        )\n\n        if (eventBasedItems.length === 0 && itemsWithCancelEvents.length === 0) {\n            return\n        }\n\n        // match any events to its corresponding item.\n        const matchEventToItem = (eventName: string, eventPayload?: CaptureResult) => {\n            this.onEvent(eventName, eventPayload)\n        }\n        this._instance?._addCaptureHook(matchEventToItem)\n\n        this._eventToItems = this._buildEventToItemMap(items, SurveyEventType.Activation)\n        this._cancelEventToItems = this._buildEventToItemMap(items, SurveyEventType.Cancellation)\n    }\n\n    onEvent(event: string, eventPayload?: CaptureResult): void {\n        const logger = this._getLogger()\n        const activatedKey = this._getActivatedKey()\n        const shownEventName = this._getShownEventName()\n\n        const existingActivatedItems: string[] = this._instance?.persistence?.props[activatedKey] || []\n        if (shownEventName === event && eventPayload && existingActivatedItems.length > 0) {\n            // remove item from activatedItems here.\n            logger.info('event matched, removing item from activated items', {\n                event,\n                eventPayload,\n                existingActivatedItems,\n            })\n            const itemId = eventPayload?.properties?.$survey_id || eventPayload?.properties?.$product_tour_id\n            if (itemId) {\n                const index = existingActivatedItems.indexOf(itemId)\n                if (index >= 0) {\n                    existingActivatedItems.splice(index, 1)\n                    this._updateActivatedItems(existingActivatedItems)\n                }\n            }\n\n            return\n        }\n\n        // check if this event should cancel any pending items\n        if (this._cancelEventToItems.has(event)) {\n            const itemsToCancel = this._getMatchingItems(event, eventPayload, SurveyEventType.Cancellation)\n\n            if (itemsToCancel.length > 0) {\n                logger.info('cancel event matched, cancelling items', {\n                    event,\n                    itemsToCancel: itemsToCancel.map((s) => s.id),\n                })\n\n                itemsToCancel.forEach((item) => {\n                    // remove from activated items\n                    const index = existingActivatedItems.indexOf(item.id)\n                    if (index >= 0) {\n                        existingActivatedItems.splice(index, 1)\n                    }\n                    // cancel any pending timeout for this item\n                    this._cancelPendingItem(item.id)\n                })\n\n                this._updateActivatedItems(existingActivatedItems)\n            }\n        }\n\n        // if the event is not in the eventToItems map, nothing else to do\n        if (!this._eventToItems.has(event)) {\n            return\n        }\n\n        logger.info('event name matched', {\n            event,\n            eventPayload,\n            items: this._eventToItems.get(event),\n        })\n\n        const matchedItems = this._getMatchingItems(event, eventPayload, SurveyEventType.Activation)\n\n        this._updateActivatedItems(existingActivatedItems.concat(matchedItems.map((item) => item.id) || []))\n    }\n\n    onAction(actionName: string): void {\n        const activatedKey = this._getActivatedKey()\n        const existingActivatedItems: string[] = this._instance?.persistence?.props[activatedKey] || []\n        if (this._actionToItems.has(actionName)) {\n            this._updateActivatedItems(existingActivatedItems.concat(this._actionToItems.get(actionName) || []))\n        }\n    }\n\n    private _updateActivatedItems(activatedItems: string[]) {\n        const logger = this._getLogger()\n        const activatedKey = this._getActivatedKey()\n        // Filter out permanently ineligible items and remove duplicates\n        const eligibleItems = [...new Set(activatedItems)].filter(\n            (itemId) => !this._isItemPermanentlyIneligible(itemId)\n        )\n        logger.info('updating activated items', {\n            activatedItems: eligibleItems,\n        })\n\n        this._instance?.persistence?.register({\n            [activatedKey]: eligibleItems,\n        })\n    }\n\n    getActivatedIds(): string[] {\n        const activatedKey = this._getActivatedKey()\n        const existingActivatedItems = this._instance?.persistence?.props[activatedKey]\n        return existingActivatedItems ? existingActivatedItems : []\n    }\n\n    getEventToItemsMap(): Map<string, string[]> {\n        return this._eventToItems\n    }\n\n    _getActionMatcher(): ActionMatcher | null | undefined {\n        return this._actionMatcher\n    }\n}\n"]}