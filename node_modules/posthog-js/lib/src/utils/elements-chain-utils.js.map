{"version":3,"file":"elements-chain-utils.js","sourceRoot":"","sources":["../../../src/utils/elements-chain-utils.ts"],"names":[],"mappings":";;AAEA,kCAGC;AAED,oCAUC;AAED,kCA0BC;AAED,gCAEC;AAjDD,sCAAyC;AAEzC,SAAgB,WAAW,CAAC,aAAqB;IAC7C,IAAM,KAAK,GAAG,aAAa,CAAC,KAAK,CAAC,qBAAqB,CAAC,CAAA;IACxD,OAAO,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAA;AAChC,CAAC;AAED,SAAgB,YAAY,CAAC,aAAqB;IAC9C,IAAM,KAAK,GAAa,EAAE,CAAA;IAC1B,IAAM,KAAK,GAAG,sBAAsB,CAAA;IACpC,IAAI,KAAK,CAAA;IACT,OAAO,CAAC,IAAA,gBAAS,EAAC,CAAC,KAAK,GAAG,KAAK,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC,CAAC,EAAE,CAAC;QACrD,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC;YAC5B,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAA;QACxB,CAAC;IACL,CAAC;IACD,OAAO,KAAK,CAAA;AAChB,CAAC;AAED,SAAgB,WAAW,CACvB,KAAgC,EAChC,OAAe,EACf,QAAwC;IAExC,IAAI,IAAA,gBAAS,EAAC,KAAK,CAAC;QAAE,OAAO,KAAK,CAAA;IAClC,QAAQ,QAAQ,EAAE,CAAC;QACf,KAAK,OAAO;YACR,OAAO,KAAK,KAAK,OAAO,CAAA;QAC5B,KAAK,UAAU,CAAC,CAAC,CAAC;YACd,2FAA2F;YAC3F,IAAM,WAAW,GAAG,OAAO;iBACtB,OAAO,CAAC,qBAAqB,EAAE,MAAM,CAAC;iBACtC,OAAO,CAAC,IAAI,EAAE,GAAG,CAAC;iBAClB,OAAO,CAAC,IAAI,EAAE,IAAI,CAAC,CAAA;YACxB,OAAO,IAAI,MAAM,CAAC,WAAW,EAAE,GAAG,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,CAAA;QACnD,CAAC;QACD,KAAK,OAAO;YACR,IAAI,CAAC;gBACD,OAAO,IAAI,MAAM,CAAC,OAAO,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,CAAA;YAC1C,CAAC;YAAC,WAAM,CAAC;gBACL,OAAO,KAAK,CAAA;YAChB,CAAC;QACL;YACI,OAAO,KAAK,CAAA;IACpB,CAAC;AACL,CAAC;AAED,SAAgB,UAAU,CAAC,KAAe,EAAE,OAAe,EAAE,QAAwC;IACjG,OAAO,KAAK,CAAC,IAAI,CAAC,UAAC,IAAI,IAAK,OAAA,WAAW,CAAC,IAAI,EAAE,OAAO,EAAE,QAAQ,CAAC,EAApC,CAAoC,CAAC,CAAA;AACrE,CAAC","sourcesContent":["import { isNullish } from '@posthog/core'\n\nexport function extractHref(elementsChain: string): string {\n    const match = elementsChain.match(/(?::|\")href=\"(.*?)\"/)\n    return match ? match[1] : ''\n}\n\nexport function extractTexts(elementsChain: string): string[] {\n    const texts: string[] = []\n    const regex = /(?::|\")text=\"(.*?)\"/g\n    let match\n    while (!isNullish((match = regex.exec(elementsChain)))) {\n        if (!texts.includes(match[1])) {\n            texts.push(match[1])\n        }\n    }\n    return texts\n}\n\nexport function matchString(\n    value: string | undefined | null,\n    pattern: string,\n    matching: 'exact' | 'contains' | 'regex'\n): boolean {\n    if (isNullish(value)) return false\n    switch (matching) {\n        case 'exact':\n            return value === pattern\n        case 'contains': {\n            // Simulating SQL LIKE behavior (_ = any single character, % = any zero or more characters)\n            const likePattern = pattern\n                .replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')\n                .replace(/_/g, '.')\n                .replace(/%/g, '.*')\n            return new RegExp(likePattern, 'i').test(value)\n        }\n        case 'regex':\n            try {\n                return new RegExp(pattern).test(value)\n            } catch {\n                return false\n            }\n        default:\n            return false\n    }\n}\n\nexport function matchTexts(texts: string[], pattern: string, matching: 'exact' | 'contains' | 'regex'): boolean {\n    return texts.some((text) => matchString(text, pattern, matching))\n}\n"]}